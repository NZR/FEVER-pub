
@book{spencer_ifdef_1992,
	title = {\#ifdef {Considered} {Harmful}, or {Portability} {Experience} {With} {C} {News}},
	author = {Spencer, Henry and Collyer, Geoff},
	year = {1992}
}

@incollection{holzl_13_2010,
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {13 {AutoFocus} 3 - {A} {Scientific} {Tool} {Prototype} for {Model}-{Based} {Development} of {Component}-{Based}, {Reactive}, {Distributed} {Systems}},
	copyright = {©2010 Springer Berlin Heidelberg},
	isbn = {978-3-642-16276-3 978-3-642-16277-0},
	url = {http://link.springer.com/chapter/10.1007/978-3-642-16277-0_13},
	abstract = {We give an introduction of the AutoFocus 3 tool, which allows component-based modeling of reactive, distributed systems and provides validation and verification mechanisms for these models. Furthermore, AutoFocus 3 includes descriptions of specific technical platforms and deployments. The modeling language is based on precise semantics including the notion of time and allows for a refinement-based methodology for the development of reactive systems, typically found in user-accessible embedded realtime-systems.},
	language = {en},
	number = {6100},
	urldate = {2014-09-19},
	booktitle = {Model-{Based} {Engineering} of {Embedded} {Real}-{Time} {Systems}},
	publisher = {Springer Berlin Heidelberg},
	author = {Hölzl, Florian and Feilkas, Martin},
	editor = {Giese, Holger and Karsai, Gabor and Lee, Edward and Rumpe, Bernhard and Schätz, Bernhard},
	month = jan,
	year = {2010},
	keywords = {Logics and Meanings of Programs, Programming Languages, Compilers, Interpreters, Programming Techniques, Simulation and Modeling, software engineering, System Performance and Evaluation},
	pages = {317--322},
	file = {Snapshot:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/UVFTKP2A/10.html:text/html}
}

@inproceedings{abal_42_2014,
	address = {New York, NY, USA},
	series = {{ASE} '14},
	title = {42 {Variability} {Bugs} in the {Linux} {Kernel}: {A} {Qualitative} {Analysis}},
	isbn = {978-1-4503-3013-8},
	shorttitle = {42 {Variability} {Bugs} in the {Linux} {Kernel}},
	url = {http://doi.acm.org/10.1145/2642937.2642990},
	doi = {10.1145/2642937.2642990},
	abstract = {Feature-sensitive verification pursues effective analysis of the exponentially many variants of a program family. However, researchers lack examples of concrete bugs induced by variability, occurring in real large-scale systems. Such a collection of bugs is a requirement for goal-oriented research, serving to evaluate tool implementations of feature-sensitive analyses by testing them on real bugs. We present a qualitative study of 42 variability bugs collected from bug-fixing commits to the Linux kernel repository. We analyze each of the bugs, and record the results in a database. In addition, we provide self-contained simplified C99 versions of the bugs, facilitating understanding and tool evaluation. Our study provides insights into the nature and occurrence of variability bugs in a large C software system, and shows in what ways variability affects and increases the complexity of software bugs.},
	urldate = {2014-10-24},
	booktitle = {Proceedings of the 29th {ACM}/{IEEE} {International} {Conference} on {Automated} {Software} {Engineering}},
	publisher = {ACM},
	author = {Abal, Iago and Brabrand, Claus and Wasowski, Andrzej},
	year = {2014},
	keywords = {bugs, feature interactions, Linux, software variability},
	pages = {421--432},
	file = {abal - 42 variability bugs - 2014.pdf:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/FSXRZABX/abal - 42 variability bugs - 2014.pdf:application/pdf;ACM Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/W5584RB6/Abal et al. - 2014 - 42 Variability Bugs in the Linux Kernel A Qualita.pdf:application/pdf}
}

@inproceedings{thum_abstract_2011,
	series = {{SPLC} '11},
	title = {Abstract {Features} in {Feature} {Modeling}},
	doi = {10.1109/SPLC.2011.53},
	abstract = {A software product line is a set of program variants, typically generated from a common code base. Feature models describe variability in product lines by documenting features and their valid combinations. In product-line engineering, we need to reason about variability and program variants for many different tasks. For example, given a feature model, we might want to determine the number of all valid feature combinations or compute specific feature combinations for testing. However, we found that contemporary reasoning approaches can only reason about feature combinations, not about program variants, because they do not take abstract features into account. Abstract features are features used to structure a feature model that, however, do not have any impact at implementation level. Using existing feature-model reasoning mechanisms for program variants leads to incorrect results. Hence, although abstract features represent domain decisions that do not affect the generation of a program variant. We raise awareness of the problem of abstract features for different kinds of analyses on feature models. We argue that, in order to reason about program variants, abstract features should be made explicit in feature models. We present a technique based on propositional formulas that enables to reason about program variants rather than feature combinations. In practice, our technique can save effort that is caused by considering the same program variant multiple times, for example, in product-line testing.},
	booktitle = {Proceedings of the 15th {International} {Software} {Product} {Line} {Conference}},
	author = {Thum, T. and Kastner, C. and Erdweg, S. and Siegmund, N.},
	month = aug,
	year = {2011},
	keywords = {abstract features, contemporary reasoning approach, feature extraction, feature modeling, feature model reasoning, software engineering, software maintenance, software product line},
	pages = {191 --200},
	file = {IEEE Xplore Abstract Record:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/XN9JWKCA/stamp.html:text/html;IEEE Xplore Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/U2XWKH4V/Thum et al. - 2011 - Abstract Features in Feature Modeling.pdf:application/pdf}
}

@inproceedings{heider_case_2012,
	series = {{WICSA}/{ESCA}'12},
	title = {A {Case} {Study} on the {Evolution} of a {Component}-based {Product} {Line}},
	doi = {10.1109/WICSA-ECSA.212.8},
	abstract = {Product line engineering is an approach that works well for managing the anticipated variability of software systems as demonstrated in numerous studies. However, little empirical research and few approaches exist for dealing with the unanticipated evolution of product lines. As a result, the understanding of product line evolution is still weak and the maturity of approaches and tools supporting evolution is often insufficient. In this paper we present results of a case study on impact analyses and desired tool support in product line evolution. Our findings are based on observing 30 person months of development. We analyzed changes made to a product line in typical evolution scenarios by involving the key developers. We used empirical data on observed development activities and impact analyses to derive a trace information model showing frequently desired trace links. We discuss lessons learned and implications for tool developers.},
	booktitle = {Proceedings of {Joint} {Working} {IEEE}/{IFIP} {Conference} on {Software} {Architecture} and {European} {Conference} on {Software} {Architecture}},
	author = {Heider, Wolfgang and Vierhauser, Michael and Lettner, Daniela and Grunbacher, Paul},
	year = {2012},
	pages = {1 --10},
	file = {IEEE Xplore Abstract Record:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/Z74RSZPW/articleDetails.html:text/html;IEEE Xplore Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/JEQFN8CH/Heider et al. - 2012 - A Case Study on the Evolution of a Component-based.pdf:application/pdf}
}

@article{thum_classification_2014,
	title = {A {Classification} and {Survey} of {Analysis} {Strategies} for {Software} {Product} {Lines}},
	volume = {47},
	issn = {0360-0300},
	doi = {10.1145/2580950},
	abstract = {Software-product-line engineering has gained considerable momentum in recent years, both in industry and in academia. A software product line is a family of software products that share a common set of features. Software product lines challenge traditional analysis techniques, such as type checking, model checking, and theorem proving, in their quest of ensuring correctness and reliability of software. Simply creating and analyzing all products of a product line is usually not feasible, due to the potentially exponential number of valid feature combinations. Recently, researchers began to develop analysis techniques that take the distinguishing properties of software product lines into account, for example, by checking feature-related code in isolation or by exploiting variability information during analysis. The emerging field of product-line analyses is both broad and diverse, so it is difficult for researchers and practitioners to understand their similarities and differences. We propose a classification of product-line analyses to enable systematic research and application. Based on our insights with classifying and comparing a corpus of 123 research articles, we develop a research agenda to guide future research on product-line analyses.},
	number = {1},
	urldate = {2014-07-21},
	journal = {ACM Comput. Surv.},
	author = {Thüm, Thomas and Apel, Sven and Kästner, Christian and Schaefer, Ina and Saake, Gunter},
	month = jun,
	year = {2014},
	keywords = {model checking, Product-line analysis, program family, software analysis, software product line, static analysis, theorem proving, type checking},
	pages = {6:1--6:45}
}

@inproceedings{benlarabi_co-evolution_2014,
	title = {A co-evolution model for software product lines: {An} approach based on evolutionary trees},
	isbn = {978-1-4799-4647-1},
	shorttitle = {A co-evolution model for software product lines},
	url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=7060991},
	doi = {10.1109/ICoCS.2014.7060991},
	urldate = {2015-06-01},
	publisher = {IEEE},
	author = {Benlarabi, Anissa and El Asri, Bouchra and Khtira, Amal},
	year = {2014},
	pages = {140--145}
}

@inproceedings{moser_comparative_2008,
	series = {{ICSE} '08},
	title = {A comparative analysis of the efficiency of change metrics and static code attributes for defect prediction},
	url = {http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=4814129},
	doi = {10.1145/1368088.1368114},
	booktitle = {Proceedings of the 30th {International} {Conference} on {Software} {Engineering}},
	author = {Moser, R. and Pedrycz, W. and Succi, G.},
	month = may,
	year = {2008},
	keywords = {Bayes methods, change metrics, Classification tree analysis, comparative analysis, Costs, cost-sensitive classification, decision tree, decision trees, defect prediction, Eclipse project, Java, Java file classification, learning (artificial intelligence), logistic regression, Logistics, machine learning, naive Bayes method, pattern classification, Permission, Predictive models, process related software metrics, product related software metrics, program diagnostics, regression analysis, Resource management, Software engineering, software metrics, software quality, static code attribute, Testing},
	pages = {181--190}
}

@inproceedings{medeiros_comparison_2016,
	address = {New York, NY, USA},
	series = {{ICSE} '16},
	title = {A {Comparison} of 10 {Sampling} {Algorithms} for {Configurable} {Systems}},
	isbn = {978-1-4503-3900-1},
	url = {http://doi.acm.org/10.1145/2884781.2884793},
	doi = {10.1145/2884781.2884793},
	abstract = {Almost every software system provides configuration options to tailor the system to the target platform and application scenario. Often, this configurability renders the analysis of every individual system configuration infeasible. To address this problem, researchers have proposed a diverse set of sampling algorithms. We present a comparative study of 10 state-of-the-art sampling algorithms regarding their fault-detection capability and size of sample sets. The former is important to improve software quality and the latter to reduce the time of analysis. In a nutshell, we found that sampling algorithms with larger sample sets are able to detect higher numbers of faults, but simple algorithms with small sample sets, such as most-enabled-disabled, are the most efficient in most contexts. Furthermore, we observed that the limiting assumptions made in previous work influence the number of detected faults, the size of sample sets, and the ranking of algorithms. Finally, we have identified a number of technical challenges when trying to avoid the limiting assumptions, which questions the practicality of certain sampling algorithms.},
	urldate = {2017-05-09},
	booktitle = {Proceedings of the 38th {International} {Conference} on {Software} {Engineering}},
	publisher = {ACM},
	author = {Medeiros, Flávio and Kästner, Christian and Ribeiro, Márcio and Gheyi, Rohit and Apel, Sven},
	year = {2016},
	pages = {643--654},
	file = {ACM Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/77A2EKVI/Medeiros et al. - 2016 - A Comparison of 10 Sampling Algorithms for Configu.pdf:application/pdf}
}

@inproceedings{passos_dataset_2014,
	address = {New York, NY, USA},
	series = {{MSR} 2014},
	title = {A {Dataset} of {Feature} {Additions} and {Feature} {Removals} from the {Linux} {Kernel}},
	isbn = {978-1-4503-2863-0},
	url = {http://doi.acm.org/10.1145/2597073.2597124},
	doi = {10.1145/2597073.2597124},
	abstract = {This paper describes a dataset of feature additions and removals in the Linux kernel evolution history, spanning over seven years of kernel development. Features, in this context, denote configurable system options that users select when creating customized kernel images. The provided dataset is the largest corpus we are aware of capturing feature additions and removals, allowing researchers to assess the kernel evolution from a feature-oriented point-of-view. Furthermore, the dataset can be used to better understand how features evolve over time, and how different artifacts change as a result. One particular use of the dataset is to provide a real-world case to assess existing support for feature traceability and evolution. In this paper, we detail the dataset extraction process, the underlying database schema, and example queries. The dataset is directly available at our Bitbucket repository: https://bitbucket.org/lpassos/kconfigdb},
	urldate = {2014-10-08},
	booktitle = {Proceedings of the 11th {Working} {Conference} on {Mining} {Software} {Repositories}},
	publisher = {ACM},
	author = {Passos, Leonardo and Czarnecki, Krzysztof},
	year = {2014},
	keywords = {evolution, Linux, traceability, Version Control History},
	pages = {376--379},
	file = {ACM Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/E9ZJC3B9/Passos and Czarnecki - 2014 - A Dataset of Feature Additions and Feature Removal.pdf:application/pdf}
}

@inproceedings{maoz_addiff:_2011,
	title = {{ADDiff}: semantic differencing for activity diagrams},
	isbn = {978-1-4503-0443-6},
	shorttitle = {{ADDiff}},
	url = {http://dl.acm.org/citation.cfm?doid=2025113.2025140},
	doi = {10.1145/2025113.2025140},
	urldate = {2016-11-01},
	publisher = {ACM Press},
	author = {Maoz, Shahar and Ringert, Jan Oliver and Rumpe, Bernhard},
	year = {2011},
	pages = {179}
}

@article{peffers_design_2007,
	title = {A {Design} {Science} {Research} {Methodology} for {Information} {Systems} {Research}},
	volume = {24},
	issn = {0742-1222},
	url = {http://www.tandfonline.com/doi/full/10.2753/MIS0742-1222240302},
	doi = {10.2753/MIS0742-1222240302},
	number = {3},
	urldate = {2016-11-18},
	journal = {Journal of Management Information Systems},
	author = {Peffers, Ken and Tuunanen, Tuure and Rothenberger, Marcus A. and Chatterjee, Samir},
	month = dec,
	year = {2007},
	pages = {45--77}
}

@article{olumofin_holistic_2007,
	title = {A holistic architecture assessment method for software product lines},
	volume = {49},
	issn = {0950-5849},
	url = {http://www.sciencedirect.com/science/article/pii/S0950584906000747},
	doi = {10.1016/j.infsof.2006.05.003},
	abstract = {The success of architecture-centric development of software product lines is critically dependent upon the availability of suitable architecture assessment methods. While a number of architecture assessment methods are available and some of them have been widely used in the process of evaluating single product architectures, none of them is equipped to deal with the main challenges of product line development. In this paper we present an adaptation of the Architecture Tradeoff Analysis Method (ATAM) for the task of assessing product line architectures. The new method, labeled Holistic Product Line Architecture Assessment (HoPLAA), uses a holistic approach that focuses on risks and quality attribute tradeoffs – not only for the common product line architecture, but for the individual product architectures as well. In addition, it prescribes a qualitative analytical treatment of variation points using scenarios. The use of the new method is illustrated through a case study.},
	number = {4},
	urldate = {2012-07-04},
	journal = {Information and Software Technology},
	author = {Olumofin, Femi G. and Mišić, Vojislav B.},
	month = apr,
	year = {2007},
	keywords = {Architecture Tradeoff Analysis Method (ATAM), Software architecture assessment, Software product line architectures},
	pages = {309--323},
	file = {HOPLAA.pdf:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/4FVSJG2A/HOPLAA.pdf:application/pdf;ScienceDirect Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/GDAWZTXB/Olumofin and Mišić - 2007 - A holistic architecture assessment method for soft.pdf:application/pdf;ScienceDirect Snapshot:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/5Z4ICIHH/S0950584906000747.html:text/html}
}

@article{mcintosh_large-scale_2014,
	title = {A {Large}-{Scale} {Empirical} {Study} of the {Relationship} between {Build} {Technology} and {Build} {Maintenance}},
	volume = {20},
	issn = {1382-3256, 1573-7616},
	url = {http://link.springer.com/article/10.1007/s10664-014-9324-x},
	doi = {10.1007/s10664-014-9324-x},
	abstract = {Build systems specify how source code is translated into deliverables. They require continual maintenance as the system they build evolves. This build maintenance can become so burdensome that projects switch build technologies, potentially having to rewrite thousands of lines of build code. We aim to understand the prevalence of different build technologies and the relationship between build technology and build maintenance by analyzing version histories in a corpus of 177,039 repositories spread across four software forges, three software ecosystems, and four large-scale projects. We study low-level, abstraction-based, and framework-driven build technologies, as well as tools that automatically manage external dependencies. We find that modern, framework-driven build technologies need to be maintained more often and these build changes are more tightly coupled with the source code than low-level or abstraction-based ones. However, build technology migrations tend to coincide with a shift of build maintenance work to a build-focused team, deferring the cost of build maintenance to them.},
	number = {6},
	urldate = {2016-07-04},
	journal = {Empirical Software Engineering},
	author = {McIntosh, Shane and Nagappan, Meiyappan and Adams, Bram and Mockus, Audris and Hassan, Ahmed E.},
	month = aug,
	year = {2014},
	keywords = {build systems, Large-scale analysis, open source, Programming Languages, Compilers, Interpreters, Software Engineering/Programming and Operating Systems, software maintenance},
	pages = {1587--1633},
	file = {Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/QSWCE7BI/McIntosh et al. - 2014 - A Large-Scale Empirical Study of the Relationship .pdf:application/pdf;Snapshot:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/Z8AGSAQF/s10664-014-9324-x.html:text/html}
}

@article{borba_algebraic_2004,
	series = {Special {Issue} on {Program} {Transformation}},
	title = {Algebraic reasoning for object-oriented programming},
	volume = {52},
	issn = {0167-6423},
	url = {http://www.sciencedirect.com/science/article/pii/S0167642304000474},
	doi = {10.1016/j.scico.2004.03.003},
	abstract = {We present algebraic laws for a language similar to a subset of sequential Java that includes inheritance, recursive classes, dynamic binding, access control, type tests and casts, assignment, but no sharing. These laws are proved sound with respect to a weakest precondition semantics. We also show that they are complete in the sense that they are sufficient to reduce an arbitrary program to a normal form substantially close to an imperative program; the remaining object-oriented constructs could be further eliminated if our language had recursive records. This suggests that our laws are expressive enough to formally derive behaviour preserving program transformations; we illustrate that through the derivation of provably-correct refactorings.},
	number = {1–3},
	urldate = {2015-05-08},
	journal = {Science of Computer Programming},
	author = {Borba, Paulo and Sampaio, Augusto and Cavalcanti, Ana and Cornélio, Márcio},
	month = aug,
	year = {2004},
	pages = {53--100},
	file = {ScienceDirect Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/SGVI7MEG/Borba et al. - 2004 - Algebraic reasoning for object-oriented programmin.pdf:application/pdf;ScienceDirect Snapshot:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/NWR9RX34/S0167642304000474.html:text/html}
}

@incollection{maoz_manifesto_2011,
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {A {Manifesto} for {Semantic} {Model} {Differencing}},
	copyright = {©2011 Springer Berlin Heidelberg},
	isbn = {978-3-642-21209-3 978-3-642-21210-9},
	url = {http://link.springer.com/chapter/10.1007/978-3-642-21210-9_19},
	abstract = {Models are heavily used in software engineering and together with their systems they evolve over time. Thus, managing their changes is an important challenge for system maintainability. Existing approaches to model differencing concentrate on heuristics matching between model elements and on finding and presenting differences at a concrete or abstract syntactic level. While showing some success, these approaches are inherently limited to comparing syntactic structures. This paper is a manifesto for research on semantic model differencing. We present our vision to develop semantic diff operators for model comparisons: operators whose input consists of two models and whose output is a set of diff witnesses, instances of one model that are not instances of the other. In particular, if the models are syntactically different but there are no diff witnesses, the models are semantically equivalent. We demonstrate our vision using two concrete diff operators, for class diagrams and for activity diagrams. We motivate the use of semantic diff operators, briefly discuss the algorithms to compute them, list related challenges, and show their application and potential use as new fundamental building blocks for change management in model-driven engineering.},
	number = {6627},
	urldate = {2015-02-14},
	booktitle = {Models in {Software} {Engineering}},
	publisher = {Springer Berlin Heidelberg},
	author = {Maoz, Shahar and Ringert, Jan Oliver and Rumpe, Bernhard},
	editor = {Dingel, Juergen and Solberg, Arnor},
	year = {2011},
	keywords = {Logics and Meanings of Programs, Management of Computing and Information Systems, Programming Languages, Compilers, Interpreters, Simulation and Modeling, software engineering},
	pages = {194--203},
	file = {Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/H8MSTBZE/Maoz et al. - 2011 - A Manifesto for Semantic Model Differencing.pdf:application/pdf;Snapshot:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/9GQ6QTBZ/10.html:text/html}
}

@article{dintzner_analysing_2015,
	title = {Analysing the {Linux} kernel feature model changes using {FMDiff}},
	issn = {1619-1366, 1619-1374},
	url = {http://link.springer.com/article/10.1007/s10270-015-0472-2},
	doi = {10.1007/s10270-015-0472-2},
	abstract = {Evolving a large scale, highly variable system is a challenging task. For such a system, evolution operations often require to update consistently both their implementation and its feature model. In this context, the evolution of the feature model closely follows the evolution of the system. The purpose of this work is to show that fine-grained feature changes can be used to guide the evolution of the highly variable system. In this paper, we present an approach to obtain fine-grained feature model changes with its supporting tool “FMDiff”. Our approach is tailored for Kconfig-based variability models and proposes a feature change classification detailing changes in features, their attributes and attribute values. We apply our approach to the Linux kernel feature model, extracting feature changes occurring in sixteen official releases. In contrast to previous studies, we found that feature modifications are responsible for most of the changes. Then, by taking advantage of the multi-platform aspect of the Linux kernel, we observe the effects of a feature change across the different architecture-specific feature models of the kernel. We found that between 10 and 50 \% of feature changes impact all the architecture-specific feature models, offering a new perspective on studies of the evolution of the Linux feature model and development practices of its developers.},
	urldate = {2016-08-18},
	journal = {Software \& Systems Modeling},
	author = {Dintzner, Nicolas and Deursen, Arie van and Pinzger, Martin},
	month = may,
	year = {2015},
	pages = {1--22},
	file = {Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/QXV2A7SU/Dintzner et al. - 2015 - Analysing the Linux kernel feature model changes u.pdf:application/pdf;Snapshot:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/378XZJJG/s10270-015-0472-2.html:text/html}
}

@inproceedings{breivold_analyzing_2008,
	title = {Analyzing software evolvability},
	booktitle = {Computer {Software} and {Applications}, 2008. {COMPSAC}'08. 32nd {Annual} {IEEE} {International}},
	author = {Breivold, H. P. and Crnkovic, I. and Eriksson, P. J.},
	year = {2008},
	pages = {327--330},
	file = {Analyzing software evolvability.pdf:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/EUIV2BBV/Analyzing software evolvability.pdf:application/pdf}
}

@inproceedings{romano_analyzing_2012,
	series = {{ICWS} '12},
	title = {Analyzing the {Evolution} of {Web} {Services} {Using} {Fine}-{Grained} {Changes}},
	doi = {10.1109/ICWS.2012.29},
	abstract = {In the service-oriented paradigm web service interfaces are considered contracts between web service subscribers and providers. However, these interfaces are continuously evolving over time to satisfy changes in the requirements and to fix bugs. Changes in a web service interface typically affect the systems of its subscribers. Therefore, it is essential for subscribers to recognize which types of changes occur in a web service interface in order to analyze the impact on his/her systems. In this paper we propose a tool called WSDLDiff to extract fine-grained changes from subsequent versions of a web service interface defined in WSDL. In contrast to existing approaches, WSDLDiff takes into account the syntax of WSDL and extracts the WSDL elements affected by changes and the types of changes. With WSDLDiff we performed a study aimed at analyzing the evolution of web services using the fine-grained changes extracted from the subsequent versions of four real world WSDL interfaces. The results of our study show that the analysis of the fine-grained changes helps web service subscribers to highlight the most frequent types of changes affecting a WSDL interface. This information can be relevant for web service subscribers who want to assess the risk associated to the usage of web services and to subscribe to the most stable ones.},
	booktitle = {Proceedings of the 19th {International} {Conference} on {Web} {Services}},
	author = {Romano, D. and Pinzger, M.},
	year = {2012},
	keywords = {Adaptation models, Computational modeling, Engines, fine grained changes, fine-grained changes, fix bugs, Marine vehicles, service-oriented architecture, service-oriented paradigm web service interfaces, software evolution, Unified modeling language, Web service evolution, Web service providers, Web services, Web service subscribers, XML},
	pages = {392--399},
	file = {IEEE Xplore Abstract Record:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/CUXNUZH8/abs_all.html:text/html;IEEE Xplore Abstract Record:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/WJAAUCZ9/abs_all.html:text/html;IEEE Xplore Abstract Record:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/UWQBKRCI/abs_all.html:text/html;IEEE Xplore Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/UJ4EVWW2/Romano and Pinzger - 2012 - Analyzing the Evolution of Web Services Using Fine.pdf:application/pdf;IEEE Xplore Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/GKK8MSES/Romano and Pinzger - 2012 - Analyzing the Evolution of Web Services Using Fine.pdf:application/pdf;IEEE Xplore Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/2GQEE4XS/Romano and Pinzger - 2012 - Analyzing the Evolution of Web Services Using Fine.pdf:application/pdf}
}

@inproceedings{liebig_analysis_2010,
	series = {{ICSE} '10},
	title = {An analysis of the variability in forty preprocessor-based software product lines},
	volume = {1},
	isbn = {978-1-60558-719-6},
	url = {http://portal.acm.org/citation.cfm?doid=1806799.1806819},
	doi = {10.1145/1806799.1806819},
	urldate = {2015-06-30},
	booktitle = {Proceedings of the 32nd {International} {Conference} on {Software} {Engineering}},
	publisher = {ACM Press},
	author = {Liebig, Jörg and Apel, Sven and Lengauer, Christian and Kästner, Christian and Schulze, Michael},
	year = {2010},
	pages = {105}
}

@inproceedings{binkley_implementation_2001,
	title = {An implementation of and experiment with semantic differencing},
	isbn = {978-0-7695-1189-4},
	url = {http://ieeexplore.ieee.org/document/972714/},
	doi = {10.1109/ICSM.2001.972714},
	urldate = {2016-11-29},
	publisher = {IEEE Comput. Soc},
	author = {Binkley, D. and Capellini, R. and Raszewski, L.R. and Smith, C.},
	year = {2001},
	pages = {82--91}
}

@incollection{guyon_introduction_2006,
	series = {Studies in {Fuzziness} and {Soft} {Computing}},
	title = {An {Introduction} to {Feature} {Extraction}},
	copyright = {©2006 Springer-Verlag Berlin Heidelberg},
	isbn = {978-3-540-35487-1 978-3-540-35488-8},
	url = {http://link.springer.com/chapter/10.1007/978-3-540-35488-8_1},
	abstract = {This chapter introduces the reader to the various aspects of feature extraction covered in this book. Section 1 reviews definitions and notations and proposes a unified view of the feature extraction problem. Section 2 is an overview of the methods and results presented in the book, emphasizing novel contributions. Section 3 provides the reader with an entry point in the field of feature extraction by showing small revealing examples and describing simple but effective algorithms. Finally, Section 4 introduces a more theoretical formalism and points to directions of research and open problems.},
	number = {207},
	urldate = {2016-10-11},
	booktitle = {Feature {Extraction}},
	publisher = {Springer Berlin Heidelberg},
	author = {Guyon, Isabelle and Elisseeff, André},
	editor = {Guyon, Isabelle and Nikravesh, Masoud and Gunn, Steve and Zadeh, Lotfi A.},
	year = {2006},
	note = {DOI: 10.1007/978-3-540-35488-8\_1},
	keywords = {Applications of Mathematics, Appl.Mathematics/Computational Methods of Engineering, Artificial Intelligence (incl. Robotics), Computer-Aided Engineering (CAD, CAE) and Design, Computer Imaging, Vision, Pattern Recognition and Graphics, Image Processing and Computer Vision},
	pages = {1--25},
	file = {Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/AHDZKT22/Guyon and Elisseeff - 2006 - An Introduction to Feature Extraction.pdf:application/pdf;Snapshot:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/M7IDKEXF/978-3-540-35488-8_1.html:text/html}
}

@incollection{borba_introduction_2011,
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {An {Introduction} to {Software} {Product} {Line} {Refactoring}},
	copyright = {©2011 Springer Berlin Heidelberg},
	isbn = {978-3-642-18022-4 978-3-642-18023-1},
	url = {http://link.springer.com/chapter/10.1007/978-3-642-18023-1_1},
	abstract = {Although software product lines (PLs) can bring significant productivity and quality improvements through strategic reuse, bootstrapping existing products into a PL, and extending a PL with more products, is often risky and expensive. These kinds of PL derivation and evolution might require substantial effort and can easily affect the behavior of existing products. To reduce these problems, we propose a notion of product line refactoring and associated transformation templates that should be part of a PL refactoring catalogue. We discuss how the notion guides and improves safety of the PL derivation and evolution processes; the transformation templates, particularly when automated, reduce the effort needed to perform these processes.},
	number = {6491},
	urldate = {2013-02-20},
	booktitle = {Generative and {Transformational} {Techniques} in {Software} {Engineering} {III}},
	publisher = {Springer Berlin Heidelberg},
	author = {Borba, Paulo},
	editor = {Fernandes, João M. and Lämmel, Ralf and Visser, Joost and Saraiva, João},
	month = jan,
	year = {2011},
	keywords = {Logics and Meanings of Programs, Mathematical Logic and Formal Languages, Programming Languages, Compilers, Interpreters, Programming Techniques, software engineering, Software Engineering/Programming and Operating Systems},
	pages = {1--26},
	file = {Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/DUTTCUF6/Borba - 2011 - An Introduction to Software Product Line Refactori.pdf:application/pdf;Snapshot:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/5NK77ACC/10.html:text/html}
}

@article{apel_overview_2009,
	title = {An {Overview} of {Feature}-{Oriented} {Software} {Development}.},
	volume = {8},
	number = {5},
	journal = {Journal of Object Technology},
	author = {Apel, Sven and Kästner, Christian},
	year = {2009},
	pages = {49--84}
}

@article{apel_overview_2009-1,
	title = {An overview of feature-oriented software development},
	volume = {8},
	abstract = {Abstract Feature-oriented software development (FOSD) is a paradigm for the construction,
customization, and synthesis of large-scale software systems. In this survey, we give an
overview and a personal perspective on the roots of FOSD, connections to other software
development paradigms, and recent developments in this field. Our aim is to point to
connections between different lines of research and to identify open issues.},
	number = {5},
	journal = {Journal of Object Technology},
	author = {Apel, Sven and Kästner, Christian},
	year = {2009},
	pages = {49--84}
}

@inproceedings{rabiser_prototype-based_2016,
	title = {A prototype-based approach for managing clones in clone-and-own product lines},
	isbn = {978-1-4503-4050-2},
	url = {http://dl.acm.org/citation.cfm?doid=2934466.2934487},
	doi = {10.1145/2934466.2934487},
	urldate = {2016-11-15},
	publisher = {ACM Press},
	author = {Rabiser, Daniela and Grunbacher, Paul and Prahofer, Herbert and Angerer, Florian},
	year = {2016},
	pages = {35--44}
}

@inproceedings{dietrich_robust_2012,
	series = {{SPLC} '12},
	title = {A robust approach for variability extraction from the {Linux} build system},
	isbn = {978-1-4503-1094-9},
	url = {http://doi.acm.org/10.1145/2362536.2362544},
	doi = {10.1145/2362536.2362544},
	abstract = {With more than 11,000 optional and alternative features, the Linux kernel is a highly configurable piece of software. Linux is generally perceived as a textbook example for preprocessor-based product derivation, but more than 65 percent of all features are actually handled by the build system. Hence, variability-aware static analysis tools have to take the build system into account. However, extracting variability information from the build system is difficult due to the declarative and turing-complete make language. Existing approaches based on text processing do not cover this challenges and tend to be tailored to a specific Linux version and architecture. This renders them practically unusable as a basis for variability-aware tool support -- Linux is a moving target! We describe a robust approach for extracting implementation variability from the Linux build system. Instead of extracting the variability information by a text-based analysis of all build scripts, our approach exploits the build system itself to produce this information. As our results show, our approach is robust and works for all versions and architectures from the (git-)history of Linux.},
	urldate = {2013-02-15},
	booktitle = {Proceedings of the 16th {International} {Conference} on {Software} {Product} {Line}},
	publisher = {ACM},
	author = {Dietrich, Christian and Tartler, Reinhard and Schröder-Preikschat, Wolfgang and Lohmann, Daniel},
	year = {2012},
	keywords = {build systems, configurability, kbuild, Linux, maintenance, static analysis, VAMOS},
	pages = {21--30},
	file = {ACM Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/QCGRRFXG/Dietrich et al. - 2012 - A robust approach for variability extraction from .pdf:application/pdf}
}

@inproceedings{malheiros_source_2012,
	title = {A {Source} {Code} {Recommender} {System} to {Support} {Newcomers}},
	isbn = {978-1-4673-1990-4 978-0-7695-4736-7},
	url = {http://ieeexplore.ieee.org/document/6340250/},
	doi = {10.1109/COMPSAC.2012.11},
	urldate = {2017-06-22},
	publisher = {IEEE},
	author = {Malheiros, Yuri and Moraes, Alan and Trindade, Cleyton and Meira, Silvio},
	month = jul,
	year = {2012},
	pages = {19--24}
}

@incollection{goos_aspect-oriented_1997,
	address = {Berlin, Heidelberg},
	title = {Aspect-oriented programming},
	volume = {1241},
	isbn = {978-3-540-63089-0 978-3-540-69127-3},
	url = {http://link.springer.com/10.1007/BFb0053381},
	urldate = {2016-12-19},
	booktitle = {{ECOOP}'97 — {Object}-{Oriented} {Programming}},
	publisher = {Springer Berlin Heidelberg},
	author = {Kiczales, Gregor and Lamping, John and Mendhekar, Anurag and Maeda, Chris and Lopes, Cristina and Loingtier, Jean-Marc and Irwin, John},
	editor = {Goos, Gerhard and Hartmanis, Juris and van Leeuwen, Jan and Akşit, Mehmet and Matsuoka, Satoshi},
	year = {1997},
	pages = {220--242}
}

@incollection{balaguer_assessing_2017,
	address = {Cham},
	title = {Assessing {Code} {Authorship}: {The} {Case} of the {Linux} {Kernel}},
	volume = {496},
	isbn = {978-3-319-57734-0 978-3-319-57735-7},
	shorttitle = {Assessing {Code} {Authorship}},
	url = {http://link.springer.com/10.1007/978-3-319-57735-7_15},
	urldate = {2017-05-22},
	booktitle = {Open {Source} {Systems}: {Towards} {Robust} {Practices}},
	publisher = {Springer International Publishing},
	author = {Avelino, Guilherme and Passos, Leonardo and Hora, Andre and Valente, Marco Tulio},
	editor = {Balaguer, Federico and Di Cosmo, Roberto and Garrido, Alejandra and Kon, Fabio and Robles, Gregorio and Zacchiroli, Stefano},
	year = {2017},
	note = {DOI: 10.1007/978-3-319-57735-7\_15},
	pages = {151--163}
}

@article{koziolek_assessing_2016,
	title = {Assessing software product line potential: an exploratory industrial case study},
	volume = {21},
	issn = {1382-3256, 1573-7616},
	shorttitle = {Assessing software product line potential},
	url = {http://link.springer.com/10.1007/s10664-014-9358-0},
	doi = {10.1007/s10664-014-9358-0},
	number = {2},
	urldate = {2016-11-15},
	journal = {Empirical Software Engineering},
	author = {Koziolek, Heiko and Goldschmidt, Thomas and de Gooijer, Thijmen and Domis, Dominik and Sehestedt, Stephan and Gamer, Thomas and Aleksy, Markus},
	month = apr,
	year = {2016},
	pages = {411--448}
}

@article{bagheri_assessing_2011,
	title = {Assessing the maintainability of software product line feature models using structural metrics},
	volume = {19},
	issn = {0963-9314},
	url = {http://www.springerlink.com/content/g3t421n8tr1407n2/abstract/},
	doi = {10.1007/s11219-010-9127-2},
	abstract = {A software product line is a unified representation of a set of conceptually similar software systems that share many common features and satisfy the requirements of a particular domain. Within the context of software product lines, feature models are tree-like structures that are widely used for modeling and representing the inherent commonality and variability of software product lines. Given the fact that many different software systems can be spawned from a single software product line, it can be anticipated that a low-quality design can ripple through to many spawned software systems. Therefore, the need for early indicators of external quality attributes is recognized in order to avoid the implications of defective and low-quality design during the late stages of production. In this paper, we propose a set of structural metrics for software product line feature models and theoretically validate them using valid measurement-theoretic principles. Further, we investigate through controlled experimentation whether these structural metrics can be good predictors (early indicators) of the three main subcharacteristics of maintainability: analyzability, changeability , and understandability . More specifically, a four-step analysis is conducted: (1) investigating whether feature model structural metrics are correlated with feature model maintainability through the employment of classical statistical correlation techniques; (2) understanding how well each of the structural metrics can serve as discriminatory references for maintainability; (3) identifying the sufficient set of structural metrics for evaluating each of the subcharacteristics of maintainability; and (4) evaluating how well different prediction models based on the proposed structural metrics can perform in indicating the maintainability of a feature model. Results obtained from the controlled experiment support the idea that useful prediction models can be built for the purpose of evaluating feature model maintainability using early structural metrics. Some of the structural metrics show significant correlation with the subjective perception of the subjects about the maintainability of the feature models.},
	number = {3},
	urldate = {2012-10-08},
	journal = {Software Quality Journal},
	author = {Bagheri, Ebrahim and Gasevic, Dragan},
	year = {2011},
	keywords = {Computer Science},
	pages = {579--612},
	file = {SpringerLink Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/DQ72SNQU/Bagheri and Gasevic - 2011 - Assessing the maintainability of software product .pdf:application/pdf;SpringerLink Snapshot:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/9TV4AZXS/abstract.html:text/html}
}

@inproceedings{matter_assigning_2009,
	title = {Assigning bug reports using a vocabulary-based expertise model of developers},
	doi = {10.1109/MSR.2009.5069491},
	abstract = {For popular software systems, the number of daily submitted bug reports is high. Triaging these incoming reports is a time consuming task. Part of the bug triage is the assignment of a report to a developer with the appropriate expertise. In this paper, we present an approach to automatically suggest developers who have the appropriate expertise for handling a bug report. We model developer expertise using the vocabulary found in their source code contributions and compare this vocabulary to the vocabulary of bug reports. We evaluate our approach by comparing the suggested experts to the persons who eventually worked on the bug. Using eight years of Eclipse development as a case study, we achieve 33.6\% top-1 precision and 71.0\% top-10 recall.},
	booktitle = {2009 6th {IEEE} {International} {Working} {Conference} on {Mining} {Software} {Repositories}},
	author = {Matter, D. and Kuhn, A. and Nierstrasz, O.},
	month = may,
	year = {2009},
	keywords = {bug reports, bug triage, Calibration, Counting circuits, developer expertise, Eclipse development, Open source software, program debugging, Prototypes, software development management, software system, software systems, source code, Vocabulary, vocabulary-based expertise model},
	pages = {131--140},
	file = {IEEE Xplore Abstract Record:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/A8K38IH4/5069491.html:text/html}
}

@article{berger_study_2013,
	title = {A {Study} of {Variability} {Models} and {Languages} in the {Systems} {Software} {Domain}},
	volume = {39},
	issn = {0098-5589},
	doi = {10.1109/TSE.2013.34},
	abstract = {Variability models represent the common and variable features of products in a product line. Since the introduction of FODA in 1990, several variability modeling languages have been proposed in academia and industry, followed by hundreds of research papers on variability models and modeling. However, little is known about the practical use of such languages. We study the constructs, semantics, usage, and associated tools of two variability modeling languages, Kconfig and CDL, which are independently developed outside academia and used in large and significant software projects. We analyze 128 variability models found in 12 open–source projects using these languages. Our study 1) supports variability modeling research with empirical data on the real-world use of its flagship concepts. However, we 2) also provide requirements for concepts and mechanisms that are not commonly considered in academic techniques, and 3) challenge assumptions about size and complexity of variability models made in academic papers. These results are of interest to researchers working on variability modeling and analysis techniques and to designers of tools, such as feature dependency checkers and interactive product configurators.},
	number = {12},
	journal = {IEEE Transactions on Software Engineering},
	author = {Berger, T. and She, S. and Lotufo, R. and Wasowski, A. and Czarnecki, K.},
	month = dec,
	year = {2013},
	keywords = {analytical models, associated language tools, Biological system modeling, CDL language, Computational modeling, computer architecture, configuration, empirical software engineering, feature dependency checkers, feature modeling, FODA, interactive product configurators, Kconfig language, language constructs, language semantics, language usage, open source, open-source projects, product line, public domain software, Semantics, simulation languages, software engineering, software product lines, software products, software projects, systems software domain, variability analysis techniques, Variability modeling, variability modeling languages, variability models},
	pages = {1611--1640},
	file = {IEEE Xplore Abstract Record:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/AKNBIQW6/login.html:text/html}
}

@inproceedings{berger_survey_2013,
	series = {{VaMoS} '13},
	title = {A survey of variability modeling in industrial practice},
	isbn = {978-1-4503-1541-8},
	url = {http://dl.acm.org/citation.cfm?doid=2430502.2430513},
	doi = {10.1145/2430502.2430513},
	urldate = {2016-01-20},
	booktitle = {Proceedings of the {Seventh} {International} {Workshop} on {Variability} {Modelling} of {Software}-intensive {Systems}},
	publisher = {ACM Press},
	author = {Berger, Thorsten and Rublack, Ralf and Nair, Divya and Atlee, Joanne M. and Becker, Martin and Czarnecki, Krzysztof and Wasowski, Andrzej},
	year = {2013},
	pages = {1}
}

@inproceedings{villela_survey_2014,
	address = {New York, NY, USA},
	series = {{SPLC} '14},
	title = {A {Survey} on {Software} {Variability} {Management} {Approaches}},
	isbn = {978-1-4503-2740-4},
	url = {http://doi.acm.org/10.1145/2648511.2648527},
	doi = {10.1145/2648511.2648527},
	abstract = {Variability Management (VM) is a key practice in the development of variant-rich systems. Over the years, attention has been paid to VM approaches adopted by traditional software product lines. The increasing demand for dynamic and highly configurable systems, however, calls for a closer look at the approaches used to develop these systems. We therefore conducted a survey with practitioners from organizations developing variant-rich systems in order to characterize the state of the practice. We also wanted to identify factors that might influence the adoption of specific VM approaches as well as the perception of problems/difficulties posed by those. We analyzed the answers of 31 respondents from thirteen countries and found that there is a correlation between the business domain and the adopted VM approaches. With regard to the problems/difficulties, the difficulty of assuring the quality of maintenance due to the explosion of dependencies was a major issue. This paper reports on relevant findings that could help companies to better understand their problems and researchers to design new/improved solutions.},
	urldate = {2014-10-06},
	booktitle = {Proceedings of the 18th {International} {Software} {Product} {Line} {Conference} - {Volume} 1},
	publisher = {ACM},
	author = {Villela, Karina and Silva, Adeline and Vale, Tassio and de Almeida, Eduardo Santana},
	year = {2014},
	keywords = {product line, state-of-the-practice, survey, variability, variability management},
	pages = {147--156},
	file = {ACM Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/4Z4K9XI5/Villela et al. - 2014 - A Survey on Software Variability Management Approa.pdf:application/pdf}
}

@article{da_mota_silveira_neto_systematic_2011,
	title = {A systematic mapping study of software product lines testing},
	volume = {53},
	issn = {0950-5849},
	doi = {10.1016/j.infsof.2010.12.003},
	abstract = {In software development, Testing is an important mechanism both to identify defects and assure that completed products work as specified. This is a common practice in single-system development, and continues to hold in Software Product Lines (SPL). Even though extensive research has been done in the SPL Testing field, it is necessary to assess the current state of research and practice, in order to provide practitioners with evidence that enable fostering its further development.
This paper focuses on Testing in SPL and has the following goals: investigate state-of-the-art testing practices, synthesize available evidence, and identify gaps between required techniques and existing approaches, available in the literature.
A systematic mapping study was conducted with a set of nine research questions, in which 120 studies, dated from 1993 to 2009, were evaluated.
Although several aspects regarding testing have been covered by single-system development approaches, many cannot be directly applied in the SPL context due to specific issues. In addition, particular aspects regarding SPL are not covered by the existing SPL approaches, and when the aspects are covered, the literature just gives brief overviews. This scenario indicates that additional investigation, empirical and practical, should be performed.
The results can help to understand the needs in SPL Testing, by identifying points that still require additional investigation, since important aspects regarding particular points of software product lines have not been addressed yet.},
	number = {5},
	urldate = {2014-03-10},
	journal = {Information and Software Technology},
	author = {da Mota Silveira Neto, Paulo Anselmo and Carmo Machado, Ivan do and McGregor, John D. and de Almeida, Eduardo Santana and de Lemos Meira, Silvio Romero},
	year = {2011},
	keywords = {Mapping study, software product lines, Software testing},
	pages = {407--423},
	file = {ScienceDirect Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/P4CFBBGH/da Mota Silveira Neto et al. - 2011 - A systematic mapping study of software product lin.pdf:application/pdf;ScienceDirect Snapshot:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/4C257EDC/S0950584910002193.html:text/html}
}

@article{holl_systematic_2012,
	title = {A systematic review and an expert survey on capabilities supporting multi product lines},
	volume = {54},
	issn = {0950-5849},
	doi = {10.1016/j.infsof.2012.02.002},
	abstract = {Complex software-intensive systems comprise many subsystems that are often based on heterogeneous technological platforms and managed by different organizational units. Multi product lines (MPLs) are an emerging area of research addressing variability management for such large-scale or ultra-large-scale systems. Despite the increasing number of publications addressing MPLs the research area is still quite fragmented.
The aims of this paper are thus to identify, describe, and classify existing approaches supporting MPLs and to increase the understanding of the underlying research issues. Furthermore, the paper aims at defining success-critical capabilities of infrastructures supporting MPLs.
Using a systematic literature review we identify and analyze existing approaches and research issues regarding MPLs. Approaches described in the literature support capabilities needed to define and operate MPLs. We derive capabilities supporting MPLs from the results of the systematic literature review. We validate and refine these capabilities based on a survey among experts from academia and industry.
The paper discusses key research issues in MPLs and presents basic and advanced capabilities supporting MPLs. We also show examples from research approaches that demonstrate how these capabilities can be realized.
We conclude that approaches supporting MPLs need to consider both technical aspects like structuring large models and defining dependencies between product lines as well as organizational aspects such as distributed modeling and product derivation by multiple stakeholders. The identified capabilities can help to build, enhance, and evaluate MPL approaches.},
	number = {8},
	urldate = {2014-03-05},
	journal = {Information and Software Technology},
	author = {Holl, Gerald and Grünbacher, Paul and Rabiser, Rick},
	year = {2012},
	keywords = {Large-scale systems, multi product lines, Product line engineering, Systematic literature review},
	pages = {828--852},
	file = {ScienceDirect Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/ITZAQWX7/Holl et al. - 2012 - A systematic review and an expert survey on capabi.pdf:application/pdf;ScienceDirect Snapshot:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/4DWNESCW/S095058491200033X.html:text/html}
}

@inproceedings{spinellis_tale_2008,
	address = {New York, NY, USA},
	series = {{ICSE} '08},
	title = {A tale of four kernels},
	isbn = {978-1-60558-079-1},
	url = {http://doi.acm.org/10.1145/1368088.1368140},
	doi = {10.1145/1368088.1368140},
	abstract = {The FreeBSD, GNU/Linux, Solaris, and Windows operating systems have kernels that provide comparable facilities. Interestingly, their code bases share almost no common parts, while their development processes vary dramatically. We analyze the source code of the four systems by collecting metrics in the areas of file organization, code structure, code style, the use of the C preprocessor, and data organization. The aggregate results indicate that across various areas and many different metrics, four systems developed using wildly different processes score comparably. This allows us to posit that the structure and internal quality attributes of a working, non-trivial software artifact will represent first and foremost the engineering requirements of its construction, with the influence of process being marginal, if any.},
	urldate = {2013-05-27},
	booktitle = {Proceedings of the 30th international conference on {Software} engineering},
	publisher = {ACM},
	author = {Spinellis, Diomidis},
	year = {2008},
	keywords = {comparison, FreeBSD, Linux, opensolaris, open source, proprietary software, wrk},
	pages = {381--390},
	file = {ACM Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/TD62T8GW/Spinellis - 2008 - A tale of four kernels.pdf:application/pdf}
}

@inproceedings{gheyi_theory_2006,
	series = {Allow {Workshop}},
	title = {A theory for feature models in alloy},
	url = {http://alloy.mit.edu/workshop/papers/gheyi.pdf},
	urldate = {2014-09-23},
	booktitle = {First alloy workshop},
	author = {Gheyi, Rohit and Massoni, Tiago and Borba, Paulo},
	year = {2006},
	pages = {71--80},
	file = {Alloy feature model.pdf:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/BUBMVVP6/Alloy feature model.pdf:application/pdf}
}

@incollection{borba_theory_2010,
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {A {Theory} of {Software} {Product} {Line} {Refinement}},
	copyright = {©2010 Springer-Verlag Berlin Heidelberg},
	isbn = {978-3-642-14807-1 978-3-642-14808-8},
	url = {http://link.springer.com/chapter/10.1007/978-3-642-14808-8_2},
	abstract = {To safely derive and evolve a software product line, it is important to have a notion of product line refactoring and its underlying refinement notion, which assures behavior preservation. In this paper we present a general theory of product line refinement by extending a previous formalization with explicit interfaces between our theory and the different languages that can be used to create product line artifacts. More important, we establish product line refinement properties that justify stepwise and compositional product line development and evolution.},
	number = {6255},
	urldate = {2015-05-08},
	booktitle = {Theoretical {Aspects} of {Computing} – {ICTAC} 2010},
	publisher = {Springer Berlin Heidelberg},
	author = {Borba, Paulo and Teixeira, Leopoldo and Gheyi, Rohit},
	editor = {Cavalcanti, Ana and Deharbe, David and Gaudel, Marie-Claude and Woodcock, Jim},
	year = {2010},
	keywords = {Computation by Abstract Devices},
	pages = {15--43},
	file = {Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/HPGU3AD5/Borba et al. - 2010 - A Theory of Software Product Line Refinement.pdf:application/pdf;Snapshot:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/KA3WBMTC/978-3-642-14808-8_2.html:text/html}
}

@inproceedings{hubaux_user_2012,
	address = {New York, NY, USA},
	series = {{VaMoS} '12},
	title = {A user survey of configuration challenges in {Linux} and {eCos}},
	isbn = {978-1-4503-1058-1},
	url = {http://doi.acm.org/10.1145/2110147.2110164},
	doi = {10.1145/2110147.2110164},
	abstract = {Operating systems expose sophisticated configurability to handle variability in hardware platforms like mobile devices, desktops, and servers. The variability model of an operating system kernel like Linux contains thousands of options guarded by hundreds of complex constraints. To guide users throughout the configuration and ensure the validity of their decisions, specialized tools known as configurators have been developed. Despite these tools, configuration still remains a difficult and challenging process. To better understand the challenges faced by users during configuration, we conducted two surveys, one among Linux users and another among eCos users. This paper presents the results of the surveys along three dimensions: configuration practice; user guidance; and language expressiveness. We hope that these results will help researchers and tool builders focus their efforts to improve tool support for software configuration.},
	urldate = {2013-02-15},
	booktitle = {Proceedings of the {Sixth} {International} {Workshop} on {Variability} {Modeling} of {Software}-{Intensive} {Systems}},
	publisher = {ACM},
	author = {Hubaux, Arnaud and Xiong, Yingfei and Czarnecki, Krzysztof},
	year = {2012},
	pages = {149--155}
}

@inproceedings{schroter_automated_2013,
	title = {Automated {Analysis} of {Dependent} {Feature} {Models}},
	isbn = {978-1-4503-1541-8},
	doi = {10.1145/2430502.2430515},
	abstract = {Feature models specify valid combinations of features in software product lines. With dependent feature models (DFMs), we apply separation of concerns to feature models for two main benefits. First, we can modularize feature models into parts relevant to groups of stakeholders. Second, we are able to model dependencies between different software product lines in a multi-product-line scenario. To ensure consistency and correctness of DFMs, we have to apply analyses, such as dead-feature detection. We discuss why DFMs challenge the detection of inconsistencies, present how to reuse existing analyses for DFMs, and propose new analyses to supplement existing ones. We apply automated analyses in five steps and evaluate the approach using DFMs specified in VELVET by our prototype VeAnalyzer.},
	urldate = {2014-02-17},
	booktitle = {Proc of the 7th {International} {Workshop} on {Variability} {Modelling} of {Software}-intensive {Systems}},
	publisher = {ACM},
	author = {Schröter, Reimar and Thüm, Thomas and Siegmund, Norbert and Saake, Gunter},
	year = {2013},
	pages = {9:1--9:5},
	file = {ACM Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/ZVKJXHXC/Schröter et al. - 2013 - Automated Analysis of Dependent Feature Models.pdf:application/pdf}
}

@article{benavides_automated_2010,
	title = {Automated analysis of feature models 20 years later: {A} literature review},
	volume = {35},
	issn = {0306-4379},
	shorttitle = {Automated analysis of feature models 20 years later},
	url = {http://www.sciencedirect.com/science/article/pii/S0306437910000025},
	doi = {10.1016/j.is.2010.01.001},
	abstract = {Software product line engineering is about producing a set of related products that share more commonalities than variabilities. Feature models are widely used for variability and commonality management in software product lines. Feature models are information models where a set of products are represented as a set of features in a single model. The automated analysis of feature models deals with the computer-aided extraction of information from feature models. The literature on this topic has contributed with a set of operations, techniques, tools and empirical results which have not been surveyed until now. This paper provides a comprehensive literature review on the automated analysis of feature models 20 years after of their invention. This paper contributes by bringing together previously disparate streams of work to help shed light on this thriving area. We also present a conceptual framework to understand the different proposals as well as categorise future contributions. We finally discuss the different studies and propose some challenges to be faced in the future.},
	number = {6},
	urldate = {2012-12-18},
	journal = {Information Systems},
	author = {Benavides, David and Segura, Sergio and Ruiz-Cortés, Antonio},
	month = sep,
	year = {2010},
	keywords = {Automated analyses, Feature models, Literature review, software product lines},
	pages = {615--636},
	file = {ScienceDirect Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/64F7ISXQ/Benavides et al. - 2010 - Automated analysis of feature models 20 years late.pdf:application/pdf;ScienceDirect Snapshot:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/DNC2TUHG/S0306437910000025.html:text/html}
}

@article{white_automated_2010,
	series = {{SPLC} 2008},
	title = {Automated diagnosis of feature model configurations},
	volume = {83},
	issn = {0164-1212},
	doi = {10.1016/j.jss.2010.02.017},
	abstract = {Software product-lines (SPLs) are software platforms that can be readily reconfigured for different project requirements. A key part of an SPL is a model that captures the rules for reconfiguring the software. SPLs commonly use feature models to capture SPL configuration rules. Each SPL configuration is represented as a selection of features from the feature model. Invalid SPL configurations can be created due to feature conflicts introduced via staged or parallel configuration or changes to the constraints in a feature model. When invalid configurations are created, a method is needed to automate the diagnosis of the errors and repair the feature selections.
This paper provides two contributions to research on automated configuration of SPLs. First, it shows how configurations and feature models can be transformed into constraint satisfaction problems to automatically diagnose errors and repair invalid feature selections. Second, it presents empirical results from diagnosing configuration errors in feature models ranging in size from 100 to 5,000 features. The results of our experiments show that our CSP-based diagnostic technique can scale up to models with thousands of features.},
	number = {7},
	urldate = {2014-05-06},
	journal = {Journal of Systems and Software},
	author = {White, J. and Benavides, D. and Schmidt, D. C. and Trinidad, P. and Dougherty, B. and Ruiz-Cortes, A.},
	month = jul,
	year = {2010},
	keywords = {configuration, Constraint satisfaction, Diagnosis, Optimization, Software product-lines},
	pages = {1094--1107},
	file = {ScienceDirect Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/D4XRSVPU/White et al. - 2010 - Automated diagnosis of feature model configuration.pdf:application/pdf;ScienceDirect Snapshot:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/QXHSW663/S016412121000049X.html:text/html}
}

@incollection{hutchison_automated_2005,
	address = {Berlin, Heidelberg},
	title = {Automated {Reasoning} on {Feature} {Models}},
	volume = {3520},
	isbn = {978-3-540-26095-0 978-3-540-32127-9},
	url = {http://link.springer.com/10.1007/11431855_34},
	urldate = {2016-10-10},
	booktitle = {Advanced {Information} {Systems} {Engineering}},
	publisher = {Springer Berlin Heidelberg},
	author = {Benavides, David and Trinidad, Pablo and Ruiz-Cortés, Antonio},
	editor = {Hutchison, David and Kanade, Takeo and Kittler, Josef and Kleinberg, Jon M. and Mattern, Friedemann and Mitchell, John C. and Naor, Moni and Nierstrasz, Oscar and Pandu Rangan, C. and Steffen, Bernhard and Sudan, Madhu and Terzopoulos, Demetri and Tygar, Dough and Vardi, Moshe Y. and Weikum, Gerhard and Pastor, Oscar and Falcão e Cunha, João},
	year = {2005},
	pages = {491--503}
}

@inproceedings{kim_automatic_2006,
	series = {{ASE} '06},
	title = {Automatic {Identification} of {Bug}-{Introducing} {Changes}},
	isbn = {978-0-7695-2579-2},
	url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=4019564},
	doi = {10.1109/ASE.2006.23},
	urldate = {2015-10-08},
	booktitle = {Proceedings of the 21st {International} {Conference} on {Automated} {Software} {Engineering}},
	publisher = {IEEE},
	author = {Kim, Sunghun and Zimmermann, Thomas and Pan, Kai and Jr. Whitehead, E.},
	year = {2006},
	pages = {81--90}
}

@inproceedings{ahsan_automatic_2009,
	title = {Automatic {Software} {Bug} {Triage} {System} ({BTS}) {Based} on {Latent} {Semantic} {Indexing} and {Support} {Vector} {Machine}},
	isbn = {978-1-4244-4779-4},
	url = {http://ieeexplore.ieee.org/document/5298419/},
	doi = {10.1109/ICSEA.2009.92},
	urldate = {2017-06-22},
	publisher = {IEEE},
	author = {Ahsan, Syed Nadeem and Ferzund, Javed and Wotawa, Franz},
	month = sep,
	year = {2009},
	pages = {216--221}
}

@phdthesis{elsner_automating_2012,
	type = {{PhD} dissertation},
	title = {Automating {Staged} {Product} {Derivation} for {Heterogeneous} {Multi}-{Product}-{Lines},},
	abstract = {Software constitutes a major cost factor when developing technical systems. To reduce this cost, systematic reuse of assets is necessary from early on when developing similar products - an approach that has become known as software product line engineering. The automation of product derivation, that is, the automated product creation from core assets, is one of the success factors of product line engineering. It has two facets: automated support during configuration of a product, such as configuration consistency checks and automated fixes, and automation of the actual generation of the product, via generative technologies, which produce product artifacts from the configuration. Three critical factors, however, currently hamper the use of automated derivation techniques in industry: the heterogeneity of product derivation mechanisms, the stages in the derivation process, and the composition of several product lines to multi-product-lines. From feature modeling to C-preprocessor-based configuration, from the first decision taken during the initial customer contact stage to the last option set in a configuration file at the system startup stage - each of possibly multiple involved product lines brings distinct product configuration and generation facilities to be used by different stakeholders at dedicated stages in the derivation process. Up to now, there are hardly any solutions neither for heterogeneity, nor for stages, nor for multi-product-lines - product derivation in industry results in an immense manual effort. No technical support is provided for configuration checking across heterogeneous configuration mechanisms, product lines, or configuration stages. Configuration inconsistencies remain unnoticed and produce high cost due to prolonged testing and reconfiguration cycles and, ultimately, due to the delivery of defective products to customers. This thesis contributes the PLiC approach, which automates staged product derivation for heterogeneous multi-product-lines. Multi-product-lines are split up into product line components (PLiCs), which base upon three principles: extraction, declaration, and restriction. The legacy configuration data of each PLiC is automatically and transparently extracted into models. The product line engineer declares further information on stages and multi-product-lines in additional, concise models. This facilitates defining model-based constraint checks and fixes that ensure consistent product configuration and product generation over the whole staged derivation process of heterogeneous multi-product-lines. The validation results show that the approach is comprehensively applicable to legacy product lines in a light-weight, little-invasive, and scalable manner. In doing so, this thesis opens the way for bringing automated product derivation from research and insular productive use to broad applicability in industrial practice., Bei der Entwicklung technischer Systeme stellt Software einen bedeutenden Kostenfaktor dar. Sind gleich mehrere, ähnliche Produkte zu entwickeln, hilft der Softwareproduktlinien-Ansatz durch frühe und systematisch geplante Wiederverwendung von Softwareanteilen die Kosten zu reduzieren. Insbesondere die automatische Produktableitung kann hierzu bedeutend beitragen, indem sie Konfigurationsbeschreibungen automatisch auf produktspezifische Sofwareanteile abbildet. Die Automation bezieht sich hierbei einerseits auf die Produktkonfiguration, welche durch automatische Überprüfung und Reparatur der Konfiguration deren Konsistenz sicherstellt, als auch auf die eigentlich Produktgenerierung, welche die Konfiguration auf Produktartefakte abbildet. Bisher behindern jedoch drei Faktoren die industrielle Anwendung automatischer Produktableitungstechniken: die Heterogenität der Produktableitungsmechanismen, mehrere Stufen innerhalb der Produktableitung und die Komposition von mehreren Produktlinien zu Multiproduktlinien. Von Merkmalmodellen bis zur Konfiguration über den C Präprozessor, von der ersten Entscheidung des Vertriebs beim Kunden bis zur letzten Konfigurationsoption vor dem Systemstart - jede der beteiligten Produktlinien bringt ihre eigenen Produktkonfigurations- und Produktgenerierungsmechanismen mit, welche von Benutzern unterschiedlichster Rollen während der verschieden Produktableitungsstufen verwendet werden. Für die heterogene und gestufte Produktableitung von Multiproduktlinien gibt es bisher kaum automatisierte Ansätze, so dass die Ableitung von Produkten in der Industrie weiterhin mit einem immensen manuellen Aufwand verbunden ist. Es gibt keine technische Unterstützung für die Konfigurationsüberprüfung über die Grenzen von Konfigurationsmechanismen, Produktlinien oder Ableitungsstufen hinaus. Konfigurationsinkonsistenzen bleiben daher unerkannt und erzeugen hohe Kosten durch erhöhten Test- und Rekonfigurationsaufwand - und führen schlimmstenfalls zur Auslieferung defekter Produkte an den Kunden. Der PLiC-Ansatz automatisiert die Produktableitung von gestuften und heterogenen Multiproduktlinien. Zunächst werden diese in Produktlinienkomponenten (product line components, PLiCs) zergliedert, welche auf drei Prinzipien basieren: Extraktion, Deklaration und Restriktion. Jegliche Konfigurationsdaten werden zunächst automatisch und transparent in ein einheitliches Modellformat überführt. Der Produktlinienentwickler deklariert zusätzliche Informationen bezüglich der Produktableitungsstufen und der Multiproduktlinien-Struktur in weiteren Modellen. Dies ermöglicht die einheitliche Definition von Konfigurationseinschränkungen und Reparaturanweisungen auf Modellebene, womit die konsistente Produktkonfiguration und -generierung über den gesamten gestuften und heterogenen Produktableitungsprozess von Multiproduktlinien sichergestellt wird. Die Validierung zeigt die umfassende Anwendbarkeit des Ansatzes auf bereits existierende Produktlinien auf, wobei er sich weiterhin als leichtgewichtig, gering-invasiv und technisch skalierbar erweist. Dadurch bereitet diese Arbeit den Weg, die automatische Produktableitung von der Forschung und von vereinzeltem produktiven Einsatz in eine breite Anwendung in der industriellen Praxis zu überführen.},
	urldate = {2014-02-17},
	school = {Friedrich-Alexander-Universität Erlangen-Nürnberg},
	author = {Elsner, Christoph},
	year = {2012},
	keywords = {Erlangen / Institut f�r Informatik Erlangen, Model-Driven Development, Modellgetriebene Entwicklung, Product Derivation, Produktableitung, software engineering, Software Product Line Engineering, Software-Produktlinienentwicklung, software reuse, Softwarewiederverwendung}
}

@inproceedings{van_ommering_building_2002,
	series = {{ICSE} '02},
	title = {Building {Product} {Populations} with {Software} {Components}},
	urldate = {2014-02-17},
	booktitle = {Proc. of the 24th {International} {Conference} on {Software} {Engineering}},
	publisher = {ACM},
	author = {van Ommering, Rob},
	year = {2002},
	keywords = {architectural description language, component based development, configuration management, diversity, product family, product population},
	pages = {255--265},
	file = {ACM Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/5KX9I2Q3/van Ommering - 2002 - Building Product Populations with Software Compone.pdf:application/pdf}
}

@inproceedings{aryani_can_2011,
	series = {{WCRE}'2011},
	title = {Can {We} {Predict} {Dependencies} {Using} {Domain} information?},
	doi = {10.1109/WCRE.2011.17},
	abstract = {Software dependencies play a vital role in program comprehension, change impact analysis and other software maintenance activities. Traditionally, these activities are supported by source code analysis, however, the source code is sometimes inaccessible, and not all stakeholders have adequate knowledge to perform such analysis. For example, non-technical domain experts and consultants raise most maintenance requests, however, they cannot predict the cost and impact of the requested changes without the support of the developers. We propose a novel approach to predict software dependencies by exploiting coupling present in domain-level information. Our approach is independent of the software implementation, hence, it can be used to evaluate architectural dependencies without access to the source code or the database. We evaluate our approach with a case study on a large-scale enterprise system, in which we demonstrate how up to 68\% of the source code dependencies and 77\% of the database dependencies are predicted solely based on domain information.},
	booktitle = {18th {Working} {Conference} on {Reverse} {Engineering}},
	author = {Aryani, A. and Perin, F. and Lungu, M. and Mahmood, A.N. and Nierstrasz, O.},
	year = {2011},
	keywords = {change impact analysis, domain-level information, program comprehension, software dependencies, software maintenance, source code analysis},
	pages = {55 --64},
	file = {IEEE Xplore Abstract Record:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/TSGVMBAZ/cookiedetectresponse.html:text/html;IEEE Xplore Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/D44XN285/Aryani et al. - 2011 - Can We Predict Dependencies Using Domain informati.pdf:application/pdf}
}

@inproceedings{giger_can_2012,
	series = {{MSR}'12},
	title = {Can we predict types of code changes? {An} empirical analysis},
	url = {http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=6224284},
	doi = {10.1109/MSR.2012.6224284},
	booktitle = {Proceedings of the 9th {IEEE} {Working} {Conference} on {Mining} {Software} {Repositories}},
	publisher = {ACM},
	author = {Giger, E. and Pinzger, M. and Gall, H.C.},
	month = jun,
	year = {2012},
	keywords = {Artificial neural networks, Azureus 3 project, change-prone file, change-proneness, Computational modeling, condition change, Correlation, Eclipse platform, fine-grained source code change, interface modification, learning (artificial intelligence), machine learning, Measurement, neural nets, neural network model, object-oriented methods, object-oriented metrics, Object oriented modeling, prediction model, Predictive models, SCC, semantics, social network centrality measures, software maintenance, software metrics, software quality, software system, source file, statement change, statement level, static source code dependency graph},
	pages = {217--226}
}

@incollection{hutchison_cddiff:_2011,
	address = {Berlin, Heidelberg},
	title = {{CDDiff}: {Semantic} {Differencing} for {Class} {Diagrams}},
	volume = {6813},
	isbn = {978-3-642-22654-0 978-3-642-22655-7},
	shorttitle = {{CDDiff}},
	url = {http://link.springer.com/10.1007/978-3-642-22655-7_12},
	urldate = {2016-11-01},
	booktitle = {{ECOOP} 2011 – {Object}-{Oriented} {Programming}},
	publisher = {Springer Berlin Heidelberg},
	author = {Maoz, Shahar and Ringert, Jan Oliver and Rumpe, Bernhard},
	editor = {Hutchison, David and Kanade, Takeo and Kittler, Josef and Kleinberg, Jon M. and Mattern, Friedemann and Mitchell, John C. and Naor, Moni and Nierstrasz, Oscar and Pandu Rangan, C. and Steffen, Bernhard and Sudan, Madhu and Terzopoulos, Demetri and Tygar, Doug and Vardi, Moshe Y. and Weikum, Gerhard and Mezini, Mira},
	year = {2011},
	pages = {230--254}
}

@inproceedings{siy_challenges_1998,
	series = {{ICSE} '98},
	title = {Challenges in {Evolving} a {Large} {Scale} {Software} {Product}},
	abstract = {Evolving a large system presents a number of signi cant challenges. Not only is the developer concerned about how to t in a new feature to a maze of existing features, he has to make surehischanges do not con ict with those being made in parallel by his colleagues. This is a minor problem in small projects with small organizations. However, as the project size scales up, so does the organization, and management of parallel tracks of development becomes a major concern. Moreover, increasing usage by customers with diverse needs pulls the evolving software into di erent directions, necessitating the evolution of multiple customized versions and compounding the already complex problem of evolving legacy systems. We will examine one such legacy system, the Lucent Technologies 5ESS R switching system. First introduced in 1982, 5ESS was envisioned to support telecommunication needs well into the next century. Already one of the largest and most complex pieces of real time code in the world, the software to run the switch still continues to evolve with new features and in an increasing number of customized versions. In order to keep up with future evolution and maintain the growing base of customers, a combined procedural and technological solution was put in place. We will discuss this particular solution and its limitations. 1},
	booktitle = {Proceedings of {Principles} of {Software} {Evolution} {Workshop} at the {International} {Software} {Engineering} {Conference}},
	author = {Siy, Harvey P. and Perry, Dewayne E.},
	year = {1998},
	pages = {251--260},
	file = {Citeseer - Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/K4EJ8DJH/Siy and Perry - 1998 - Challenges in Evolving a Large Scale Software Prod.pdf:application/pdf;Citeseer - Snapshot:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/2FG368AH/summary.html:text/html}
}

@inproceedings{mens_challenges_2005,
	title = {Challenges in {Software} {Evolution}},
	isbn = {0-7695-2349-8},
	url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=1572302},
	doi = {10.1109/IWPSE.2005.7},
	urldate = {2015-06-16},
	booktitle = {International {Workshop} on {Principles} of {Software} {Evolution}},
	publisher = {IEEE},
	author = {Mens, T. and Wermelinger, M. and Ducasse, S. and Demeyer, S. and Hirschfeld, R. and Jazayeri, M.},
	year = {2005},
	pages = {13--22}
}

@inproceedings{schirmeier_challenges_2009,
	series = {{HICSS} '09},
	title = {Challenges in {Software} {Product} {Line} {Composition}},
	doi = {10.1109/HICSS.2009.106},
	abstract = {The idea to develop applications and infrastructure software as software product lines (SPLs) is continuously growing in acceptance throughout the software industry. The ability to customize software to customer needs or a specific application scenario, and the advantages arising from code reuse throughout the product line will further enhance this trend in the future. Although the construction and the automated configuration of single SPLs is already well understood, new challenges come into being from the composition of multiple product lines from potentially different software producers. This article discusses several problems oriThe idea to develop applications and infrastructure software as software product lines (SPLs) is continuously growing in acceptance throughout the software industry. The ability to customize software to customer needs or a specific application scenario, and the advantages arising from code reuse throughout the product line will further enhance this trend in the future. Although the construction and the automated configuration of single SPLs is already well understood, new challenges come into being from the composition of multiple product lines from potentially different software producers. This article discusses several problems originating in multi-layer and multi-instance composition of SPLs, which we expect to be a common situation in the future. Focusing on infrastructure SPLs and the resource-constrained embedded systems domain, we describe possible approaches and starting points for prospective research.ginating in multi-layer and multi-instance composition of SPLs, which we expect to be a common situation in the future. Focusing on infrastructure SPLs and the resource-constrained embedded systems domain, we describe possible approaches and starting points for prospective research.},
	booktitle = {Proc. of the 42nd {Hawaii} {International} {Conference} on {System} {Sciences}},
	publisher = {IEEE},
	author = {Schirmeier, H. and Spinczyk, O.},
	month = jan,
	year = {2009},
	keywords = {Application software, Automotive engineering, code reuse throughout, computer architecture, Computer industry, Construction industry, DP industry, Embedded software, Embedded system, embedded systems, infrastructure software development, Operating Systems, resource-constrained embedded systems domain, Resource management, software industry, software product line composition, software reusability, software systems},
	file = {IEEE Xplore Abstract Record:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/ZPWWZFD7/abs_all.html:text/html;IEEE Xplore Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/7H8HNTUG/Schirmeier and Spinczyk - 2009 - Challenges in Software Product Line Composition.pdf:application/pdf}
}

@article{soetens_change-based_2016,
	title = {Change-based test selection: an empirical evaluation},
	volume = {21},
	issn = {1382-3256, 1573-7616},
	shorttitle = {Change-based test selection},
	url = {http://link.springer.com/10.1007/s10664-015-9405-5},
	doi = {10.1007/s10664-015-9405-5},
	number = {5},
	urldate = {2016-09-07},
	journal = {Empirical Software Engineering},
	author = {Soetens, Quinten David and Demeyer, Serge and Zaidman, Andy and Pérez, Javier},
	month = oct,
	year = {2016},
	pages = {1990--2032}
}

@article{fluri_change_2007,
	title = {Change {Distilling}:{Tree} {Differencing} for {Fine}-{Grained} {Source} {Code} {Change} {Extraction}},
	volume = {33},
	issn = {0098-5589},
	shorttitle = {Change {Distilling}},
	doi = {10.1109/TSE.2007.70731},
	abstract = {A key issue in software evolution analysis is the identification of particular changes that occur across several versions of a program. We present change distilling, a tree differencing algorithm for fine-grained source code change extraction. For that, we have improved the existing algorithm by Chawathe et al. for extracting changes in hierarchically structured data. Our algorithm extracts changes by finding both a match between the nodes of the compared two abstract syntax trees and a minimum edit script that can transform one tree into the other given the computed matching. As a result, we can identify fine-grained change types between program versions according to our taxonomy of source code changes. We evaluated our change distilling algorithm with a benchmark that we developed, which consists of 1,064 manually classified changes in 219 revisions of eight methods from three different open source projects. We achieved significant improvements in extracting types of source code changes: Our algorithm approximates the minimum edit script 45 percent better than the original change extraction approach by Chawathe et al. We are able to find all occurring changes and almost reach the minimum conforming edit script, that is, we reach a mean absolute percentage error of 34 percent, compared to the 79 percent reached by the original algorithm. The paper describes both our change distilling algorithm and the results of our evolution.},
	number = {11},
	journal = {IEEE Transactions on Software Engineering},
	author = {Fluri, B. and Wursch, M. and Pinzger, M. and Gall, H.C.},
	month = nov,
	year = {2007},
	keywords = {abstract syntax trees, Algorithm design and analysis, change distilling tree differencing algorithm, data mining, fine-grained source code change extraction, History, Maintenance engineering, minimum edit script, Programming profession, Software algorithms, software evolution analysis, software maintenance, Software prototyping, software repositories, software systems, software tools, Source code change extraction, Taxonomy, tree data structures, tree differencing algorithms},
	pages = {725--743},
	file = {IEEE Xplore Abstract Record:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/W5ISDGF3/abs_all.html:text/html;IEEE Xplore Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/ACXCDFNK/Fluri et al. - 2007 - Change DistillingTree Differencing for Fine-Grain.pdf:application/pdf}
}

@incollection{paskevicius_change_2012,
	series = {Communications in {Computer} and {Information} {Science}},
	title = {Change {Impact} {Analysis} of {Feature} {Models}},
	copyright = {©2012 Springer-Verlag Berlin Heidelberg},
	isbn = {978-3-642-33307-1 978-3-642-33308-8},
	abstract = {Changeability is a fundamental property of software systems. Every software system must evolve at all levels of abstraction (models, architecture, source code, documentation, etc.) to meet changing user and context requirements. To assess the extent of a change, change impact analysis must be performed. In this paper, we propose a taxonomy of change aspects in feature modelling domain, and analyse changeability of feature models, a high level representation of system’s external user-visible characteristics. We propose the change impact model based on a feature dependency matrix to assess validity of feature change, to follow feature change propagation and to estimate changeability of a feature model using a Jaccard distance measure. The model is implemented using Prolog logic rules. A case study is presented.},
	number = {319},
	urldate = {2013-01-24},
	booktitle = {Information and {Software} {Technologies}},
	publisher = {Springer Berlin Heidelberg},
	author = {Paskevicius, Paulius and Damasevicius, Robertas and Štuikys, Vytautas},
	editor = {Skersys, Tomas and Butleris, Rimantas and Butkiene, Rita},
	year = {2012},
	keywords = {Artificial Intelligence (incl. Robotics), changeability, Computer Appl. in Administrative Data Processing, Computers and Education, feature modelling, Information Storage and Retrieval, Information Systems Applications (incl. Internet), software engineering, software evolution},
	pages = {108--122},
	file = {Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/VTRBTGHT/Paskevicius et al. - 2012 - Change Impact Analysis of Feature Models.pdf:application/pdf;Snapshot:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/TX8VTIPH/10.html:text/html}
}

@article{sunghun_kim_classifying_2008,
	title = {Classifying {Software} {Changes}: {Clean} or {Buggy}?},
	volume = {34},
	issn = {0098-5589},
	shorttitle = {Classifying {Software} {Changes}},
	url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=4408585},
	doi = {10.1109/TSE.2007.70773},
	number = {2},
	urldate = {2015-10-08},
	journal = {IEEE Transactions on Software Engineering},
	author = {{Sunghun Kim} and Whitehead, E.J. and {Yi Zhang}},
	month = mar,
	year = {2008},
	pages = {181--196}
}

@inproceedings{begel_codebook:_2010,
	series = {{ICSE} '10},
	title = {Codebook: discovering and exploiting relationships in software repositories},
	volume = {1},
	isbn = {978-1-60558-719-6},
	shorttitle = {Codebook},
	url = {http://portal.acm.org/citation.cfm?doid=1806799.1806821},
	doi = {10.1145/1806799.1806821},
	urldate = {2016-01-18},
	booktitle = {Proceedings of the 32nd {ACM}/{IEEE} {International} {Conference} on {Software} {Engineering}},
	publisher = {ACM Press},
	author = {Begel, Andrew and Phang, Khoo Yit and Zimmermann, Thomas},
	year = {2010},
	pages = {125}
}

@inproceedings{seidl_co-evolution_2012,
	series = {{SPLC} '12},
	title = {Co-evolution of models and feature mapping in software product lines},
	isbn = {978-1-4503-1094-9},
	url = {http://doi.acm.org/10.1145/2362536.2362550},
	doi = {10.1145/2362536.2362550},
	abstract = {Software Product Lines (SPLs) are a successful approach to software reuse in the large. Even though tools exist to create SPLs, their evolution is widely unexplored. Evolving an SPL manually is tedious and error-prone as it is hard to avoid unintended side-effects that may harm the consistency of the SPL. The main contribution of this paper is the conceptual basis of a system for the evolution of model-based SPLs, which maintains consistency of models and feature mapping. As further contribution, a novel classification is introduced that distinguishes evolutions by their potential to harm the mapping of an SPL. In addition, multiple remapping operators are presented that can remedy the negative side-effects of evolutions in order to co-evolve the feature mapping. Finally, an implementation of the evolution system in the SPL tool FeatureMapper is provided to demonstrate the capabilities of the presented approach when co-evolving models and feature mapping of an SPL.},
	urldate = {2013-02-20},
	booktitle = {Proceedings of the 16th {International} {Software} {Product} {Line} {Conference}},
	publisher = {ACM},
	author = {Seidl, Christoph and Heidenreich, Florian and Aßmann, Uwe},
	year = {2012},
	keywords = {co-evolution, evolution, feature mapping, feature modeling, model transformation, software product lines},
	pages = {76--85},
	file = {ACM Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/JJ8EGC2C/Seidl et al. - 2012 - Co-evolution of models and feature mapping in soft.pdf:application/pdf}
}

@inproceedings{hellebrand_coevolution_2014,
	address = {New York, NY, USA},
	series = {{SPLC} '14},
	title = {Coevolution of {Variability} {Models} and {Code}: {An} {Industrial} {Case} {Study}},
	volume = {1},
	isbn = {978-1-4503-2740-4},
	shorttitle = {Coevolution of {Variability} {Models} and {Code}},
	url = {http://doi.acm.org/10.1145/2648511.2648542},
	doi = {10.1145/2648511.2648542},
	abstract = {In Software Engineering, reuse of artifacts is essential for high productivity. Different studies have shown that efficient reuse needs systematic planning and realization. Variability Management plays a key role in Software Product Line Engineering. We investigate code artifacts and variability models of a real-world Software Product Line over time in order to clarify whether code and variability model evolve congeneric. Furthermore, we suggest and test metrics that would allow detecting variability erosion in the code based on changes in the variability model.},
	urldate = {2015-02-14},
	booktitle = {Proceedings of the 18th {International} {Software} {Product} {Line} {Conference}},
	publisher = {ACM},
	author = {Hellebrand, Robert and Silva, Adeline and Becker, Martin and Zhang, Bo and Sierszecki, Krzysztof and Savolainen, Juha},
	year = {2014},
	keywords = {coevolution, Feature models, metrics, product line evolution},
	pages = {274--283},
	file = {ACM Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/UQ68PZVQ/Hellebrand et al. - 2014 - Coevolution of Variability Models and Code An Ind.pdf:application/pdf}
}

@article{passos_coevolution_2015,
	title = {Coevolution of variability models and related software artifacts},
	issn = {1382-3256, 1573-7616},
	url = {http://link.springer.com/article/10.1007/s10664-015-9364-x},
	doi = {10.1007/s10664-015-9364-x},
	abstract = {Variant-rich software systems offer a large degree of customization, allowing users to configure the target system according to their preferences and needs. Facing high degrees of variability, these systems often employ variability models to explicitly capture user-configurable features (e.g., systems options) and the constraints they impose. The explicit representation of features allows them to be referenced in different variation points across different artifacts, enabling the latter to vary according to specific feature selections. In such settings, the evolution of variability models interplays with the evolution of related artifacts, requiring the two to evolve together, or coevolve. Interestingly, little is known about how such coevolution occurs in real-world systems, as existing research has focused mostly on variability evolution as it happens in variability models only. Furthermore, existing techniques supporting variability evolution are usually validated with randomly-generated variability models or evolution scenarios that do not stem from practice. As the community lacks a deep understanding of how variability evolution occurs in real-world systems and how it relates to the evolution of different kinds of software artifacts, it is not surprising that industry reports existing tools and solutions ineffective, as they do not handle the complexity found in practice. Attempting to mitigate this overall lack of knowledge and to support tool builders with insights on how variability models coevolve with other artifact types, we study a large and complex real-world variant-rich software system: the Linux kernel. Specifically, we extract variability-coevolution patterns capturing changes in the variability model of the Linux kernel with subsequent changes in Makefiles and C source code. From the analysis of the patterns, we report on findings concerning evolution principles found in the kernel, and we reveal deficiencies in existing tools and theory when handling changes captured by our patterns.},
	urldate = {2015-05-08},
	journal = {Empirical Software Engineering},
	author = {Passos, Leonardo and Teixeira, Leopoldo and Dintzner, Nicolas and Apel, Sven and Wasowski, Andrzej and Czarnecki, Krzysztof and Borba, Paulo and Guo, Jianmei},
	month = may,
	year = {2015},
	keywords = {evolution, Linux, patterns, Programming Languages, Compilers, Interpreters, Software Engineering/Programming and Operating Systems, software product lines, variability},
	pages = {1--50},
	file = {Snapshot:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/X449IX3W/s10664-015-9364-x.html:text/html}
}

@inproceedings{lee_combining_2006,
	series = {{SPLC} '06},
	title = {Combining feature-oriented analysis and aspect-oriented programming for product line asset development},
	doi = {10.1109/SPLINE.2006.1691582},
	abstract = {Feature-oriented analysis (FOA) provides key information for developing reusable and adaptable product line assets. The information includes commonalities and variabilities, various dependencies between features, and their binding time information. On the other hand, aspect-oriented programming (AOP) provides effective mechanisms for encapsulating crosscutting concerns into separate entities, called aspects. By tightly coupling FOA with AOP, we can enhance reusability, adaptability, and configurability of product line assets. In this paper, we present detailed guidelines on how FOA and AOP can be combined. To validate our approach, we applied it to the engineering of an intelligent service robot product line},
	booktitle = {Proceedings of the 10th {International} {Conference} on {Software} {Product} {Line}},
	author = {Lee, Kwanwoo and Kang, K.C. and Kim, Minseong and Park, Sooyong},
	year = {2006},
	keywords = {Aspect-oriented programming, feature-oriented analysis, industrial robots, intelligent service robot product line, production engineering computing, product line asset development, service robots},
	pages = {10 pp. --112},
	file = {IEEE Xplore Abstract Record:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/QSZ2FW3Z/cookiedetectresponse.html:text/html;IEEE Xplore Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/SZUQIA4S/Lee et al. - 2006 - Combining feature-oriented analysis and aspect-ori.pdf:application/pdf}
}

@inproceedings{acher_comparing_2010,
	series = {{ECMFA} '10},
	title = {Comparing {Approaches} to {Implement} {Feature} {Model} {Composition}},
	copyright = {©2010 Springer-Verlag Berlin Heidelberg},
	isbn = {978-3-642-13594-1 978-3-642-13595-8},
	abstract = {The use of Feature Models (FMs) to define the valid combinations of features in Software Product Lines (SPL) is becoming commonplace. To enhance the scalability of FMs, support for composing FMs describing different SPL aspects is needed. Some composition operators, with interesting property preservation capabilities, have already been defined but a comprehensive and efficient implementation is still to be proposed. In this paper, we systematically compare strengths and weaknesses of different implementation approaches. The study provides some evidence that using generic model composition frameworks are not helping much in the realization, whereas a specific solution is finally necessary and clearly stands out by its qualities.},
	urldate = {2014-05-06},
	booktitle = {Proc. of the 6th {European} {Conf}. on {Modelling} {Foundations} and {Applications}},
	publisher = {Springer Berlin Heidelberg},
	author = {Acher, Mathieu and Collet, Philippe and Lahire, Philippe and France, Robert},
	editor = {Kühne, Thomas and Selic, Bran and Gervais, Marie-Pierre and Terrier, François},
	month = jun,
	year = {2010},
	keywords = {Computer Communication Networks, Logics and Meanings of Programs, Management of Computing and Information Systems, Programming Languages, Compilers, Interpreters, Programming Techniques, software engineering},
	pages = {3--19},
	file = {Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/BFS35EZ3/Acher et al. - 2010 - Comparing Approaches to Implement Feature Model Co.pdf:application/pdf;Snapshot:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/HEV3K5EU/10.html:text/html}
}

@inproceedings{giger_comparing_2011,
	address = {New York, NY, USA},
	series = {{MSR} '11},
	title = {Comparing {Fine}-grained {Source} {Code} {Changes} and {Code} {Churn} for {Bug} {Prediction}},
	isbn = {978-1-4503-0574-7},
	url = {http://doi.acm.org/10.1145/1985441.1985456},
	doi = {10.1145/1985441.1985456},
	abstract = {A significant amount of research effort has been dedicated to learning prediction models that allow project managers to efficiently allocate resources to those parts of a software system that most likely are bug-prone and therefore critical. Prominent measures for building bug prediction models are product measures, e.g., complexity or process measures, such as code churn. Code churn in terms of lines modified (LM) and past changes turned out to be significant indicators of bugs. However, these measures are rather imprecise and do not reflect all the detailed changes of particular source code entities during maintenance activities. In this paper, we explore the advantage of using fine-grained source code changes (SCC) for bug prediction. SCC captures the exact code changes and their semantics down to statement level. We present a series of experiments using different machine learning algorithms with a dataset from the Eclipse platform to empirically evaluate the performance of SCC and LM. The results show that SCC outperforms LM for learning bug prediction models.},
	urldate = {2014-10-06},
	booktitle = {Proceedings of the 8th {Working} {Conference} on {Mining} {Software} {Repositories}},
	publisher = {ACM},
	author = {Giger, Emanuel and Pinzger, Martin and Gall, Harald C.},
	year = {2011},
	keywords = {code churn, nonlinear regression, prediction models, software bugs, source code changes},
	pages = {83--92},
	file = {ACM Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/NIWAWDU4/Giger et al. - 2011 - Comparing Fine-grained Source Code Changes and Cod.pdf:application/pdf}
}

@incollection{lee_concepts_2002,
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Concepts and {Guidelines} of {Feature} {Modeling} for {Product} {Line} {Software} {Engineering}},
	volume = {2319},
	isbn = {978-3-540-43483-2},
	url = {http://www.springerlink.com/content/0tm11jqvxlucp4bh/abstract/},
	abstract = {Product line software engineering (PLSE) is an emerging software engineering paradigm, which guides organizations toward the development of products from core assets rather than the development of products one by one from scratch. In order to develop highly reusable core assets, PLSE must have the ability to exploit commonality and manage variability among products from a domain perspective. Feature modeling is one of the most popular domain analysis techniques, which analyzes commonality and variability in a domain to develop highly reusable core assets for a product line. Various attempts have been made to extend and apply it to the development of software product lines. However, feature modeling can be difficult and time-consuming without a precise understanding of the goals of feature modeling and the aid of practical guidelines. In this paper, we clarify the concept of features and the goals of feature modeling, and provide practical guidelines for successful product line software engineering. The authors have extensively used feature modeling in several industrial product line projects and the guidelines described in this paper are based on these experiences.},
	urldate = {2012-10-19},
	booktitle = {Software {Reuse}: {Methods}, {Techniques}, and {Tools}},
	publisher = {Springer Berlin / Heidelberg},
	author = {Lee, Kwanwoo and Kang, Kyo and Lee, Jaejoon},
	editor = {Gacek, Cristina},
	year = {2002},
	keywords = {Computer Science, Management of Computing and Information Systems, Programming Techniques, software engineering},
	pages = {62--77},
	file = {Snapshot:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/A3JWW4HB/10.html:text/html;SpringerLink Snapshot:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/7HRB6WS2/abstract.html:text/html}
}

@inproceedings{wang_concern_2011,
	series = {{WCRE} '11},
	title = {Concern {Localization} using {Information} {Retrieval}: {An} {Empirical} {Study} on {Linux} {Kernel}},
	shorttitle = {Concern {Localization} using {Information} {Retrieval}},
	booktitle = {Proceedings of the 18th {Working} {Conference} on {Reverse} {Engineering}},
	author = {Wang, S. and Lo, D. and Xing, Z. and Jiang, L.},
	year = {2011},
	pages = {92--96},
	file = {Concern Localization using Information Retrieval- an empyrical study on Linux Kernel.pdf:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/6PMNI24W/Concern Localization using Information Retrieval- an empyrical study on Linux Kernel.pdf:application/pdf}
}

@article{guo_consistency_2012,
	title = {Consistency maintenance for evolving feature models},
	volume = {39},
	issn = {09574174},
	url = {http://linkinghub.elsevier.com/retrieve/pii/S0957417411014990},
	doi = {10.1016/j.eswa.2011.10.014},
	number = {5},
	urldate = {2013-08-27},
	journal = {Expert Systems with Applications},
	author = {Guo, Jianmei and Wang, Yinglin and Trinidad, Pablo and Benavides, David},
	year = {2012},
	pages = {4987--4998},
	file = {Guo et al - Consistency Maintenance for evolving feature models - 2012.pdf:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/GTEMFPVW/Guo et al - Consistency Maintenance for evolving feature models - 2012.pdf:application/pdf}
}

@article{german_continuously_2015,
	title = {Continuously mining distributed version control systems: an empirical study of how {Linux} uses {Git}},
	issn = {1382-3256, 1573-7616},
	shorttitle = {Continuously mining distributed version control systems},
	url = {http://link.springer.com/10.1007/s10664-014-9356-2},
	doi = {10.1007/s10664-014-9356-2},
	urldate = {2016-01-11},
	journal = {Empirical Software Engineering},
	author = {German, Daniel M. and Adams, Bram and Hassan, Ahmed E.},
	month = mar,
	year = {2015}
}

@inproceedings{czarnecki_cool_2012,
	series = {{VaMoS} '12},
	title = {Cool {Features} and {Tough} {Decisions}: {A} {Comparison} of {Variability} {Modeling} {Approaches}},
	isbn = {978-1-4503-1058-1},
	shorttitle = {Cool {Features} and {Tough} {Decisions}},
	doi = {10.1145/2110147.2110167},
	abstract = {Variability modeling is essential for defining and managing the commonalities and variabilities in software product lines. Numerous variability modeling approaches exist today to support domain and application engineering activities. Most are based on feature modeling (FM) or decision modeling (DM), but so far no systematic comparison exists between these two classes of approaches. Over the last two decades many new features have been added to both FM and DM and it is tough to decide which approach to use for what purpose. This paper clarifies the relation between FM and DM. We aim to systematize the research field of variability modeling and to explore potential synergies. We compare multiple aspects of FM and DM ranging from historical origins and rationale, through syntactic and semantic richness, to tool support, identifying commonalities and differences. We hope that this effort will improve the understanding of the range of approaches to variability modeling by discussing the possible variations. This will provide insights to users considering adopting variability modeling in practice and to designers of new languages, such as the new OMG Common Variability Language.},
	urldate = {2014-03-10},
	booktitle = {Proc. of the {Sixth} {International} {Workshop} on {Variability} {Modeling} of {Software}-{Intensive} {Systems}},
	publisher = {ACM},
	author = {Czarnecki, Krzysztof and Grünbacher, Paul and Rabiser, Rick and Schmid, Klaus and Wasowski, Andrzej},
	year = {2012},
	keywords = {decision modeling, feature modeling, product lines, Variability modeling},
	pages = {173--182},
	file = {ACM Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/J5G9K9I2/Czarnecki et al. - 2012 - Cool Features and Tough Decisions A Comparison of.pdf:application/pdf}
}

@incollection{oreilly_criterion_1997,
	address = {Swindon, UK},
	title = {Criterion validation of the interim revised social classification},
	booktitle = {Constructing {Classes}: {Towards} a {New} {Social} {Classification} for the {UK}},
	publisher = {Economic and Social Research Council and Office for National Statistics},
	author = {O'Reilly, Karen and Rose, David},
	year = {1997}
}

@inproceedings{tartler_dead_2009,
	series = {{FOSD} '09},
	title = {Dead or alive: {Finding} zombie features in the {Linux} kernel},
	shorttitle = {Dead or alive},
	url = {http://dl.acm.org/citation.cfm?id=1629732},
	urldate = {2013-08-29},
	booktitle = {Proceedings of the {First} {International} {Workshop} on {Feature}-{Oriented} {Software} {Development}},
	author = {Tartler, Reinhard and Sincero, Julio and Schröder-Preikschat, Wolfgang and Lohmann, Daniel},
	year = {2009},
	pages = {81--86},
	file = {Tartler et al. - Dead or Alive - 2009:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/N3FQ8CXI/Tartler et al. - Dead or Alive - 2009:application/pdf}
}

@article{mendonca_decision-making_2010,
	title = {Decision-making coordination and efficient reasoning techniques for feature-based configuration},
	volume = {75},
	issn = {0167-6423},
	doi = {10.1016/j.scico.2009.12.004},
	abstract = {Software Product Lines is a contemporary approach to software development that exploits the similarities and differences within a family of systems in a particular domain of interest in order to provide a common infrastructure for deriving members of this family in a timely fashion, with high-quality standards, and at lower costs.
In Software Product Lines, feature-based product configuration is the process of selecting the desired features for a given software product from a repository of features called a feature model. This process is usually carried out collaboratively by people with distinct skills and interests called stakeholders. Collaboration benefits stakeholders by allowing them to directly intervene in the configuration process. However, collaboration also raises an important side effect, i.e., the need of stakeholders to cope with decision conflicts. Conflicts arise when decisions that are locally consistent cannot be applied globally because they violate one or more constraints in the feature model.
Unfortunately, current product configuration systems are typically single-user-based in the sense that they do not provide means to coordinate concurrent decision-making on the feature model. As a consequence, configuration is carried out by a single person that is in charge of representing the interests of all stakeholders and managing decision conflicts on their own. This results in an error-prone and time-consuming process that requires past decisions to be revisited continuously either to correct misinterpreted stakeholder requirements or to handle decision conflicts. Yet another challenging issue related to configuration problems is the typically high computational cost of configuration algorithms. In fact, these algorithms frequently fall into the category of NP-hard and thus can become intractable in practice.
In this paper, our goal is two-fold. First, we revisit our work on Collaborative Product Configuration (CPC) in which we proposed an approach to describe and validate collaborative configuration scenarios. We discuss how collaborative configuration can be described in terms of a workflow-like plan that safely guides stakeholders during the configuration process. Second, we propose a preliminary set of reasoning algorithms tailored to the feature modelling domain that can be used to provide automated support for product configuration. In addition, we compare empirically the performance of the proposed algorithms to that of a general-purpose solution. We hope that the insights provided in this paper will encourage other researchers to develop new algorithms in the near future.},
	number = {5},
	urldate = {2014-02-21},
	journal = {Science of Computer Programming},
	author = {Mendonca, Marcilio and Cowan, Donald},
	month = may,
	year = {2010},
	keywords = {Automated reasoning, Constraint-based reasoning, Decision-making coordination, feature modelling, Feature models, Product configuration, software product lines},
	pages = {311--332},
	file = {ScienceDirect Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/I699J4SV/Mendonca and Cowan - 2010 - Decision-making coordination and efficient reasoni.pdf:application/pdf;ScienceDirect Snapshot:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/734NDTUA/S0167642309001713.html:text/html}
}

@book{bosch_design_2000,
	title = {Design and {Use} of {Software} {Architectures}: {Adopting} and {Evolving} a {Product}-line {Approach}},
	isbn = {978-0-201-67494-1},
	shorttitle = {Design and {Use} of {Software} {Architectures}},
	abstract = {This book provides an achievable answer. The author proposes a method for designing software architectures, and product line architectures, which is based on his experience in industry and research. The first part of the book introduces the design method,},
	publisher = {Pearson Education},
	author = {Bosch, Jan},
	year = {2000},
	keywords = {Computers / General, Computers / Software Development \& Engineering / General, Computers / Systems Architecture / General}
}

@article{hevner_design_2004,
	title = {Design {Science} in {Information} {Systems} {Research}},
	volume = {28},
	issn = {0276-7783},
	url = {http://dl.acm.org/citation.cfm?id=2017212.2017217},
	abstract = {Two paradigms characterize much of the research in the Information Systems discipline: behavioral science and design science. The behavioral-science paradigm seeks to develop and verify theories that explain or predict human or organizational behavior. The design-science paradigm seeks to extend the boundaries of human and organizational capabilities by creating new and innovative artifacts. Both paradigms are foundational to the IS discipline, positioned as it is at the confluence of people, organizations, and technology. Our objective is to describe the performance of design-science research in Information Systems via a concise conceptual framework and clear guidelines for understanding, executing, and evaluating the research. In the design-science paradigm, knowledge and understanding of a problem domain and its solution are achieved in the building and application of the designed artifact. Three recent exemplars in the research literature are used to demonstrate the application of these guidelines. We conclude with an analysis of the challenges of performing high-quality design-science research in the context of the broader IS community.},
	number = {1},
	urldate = {2016-11-18},
	journal = {MIS Q.},
	author = {Hevner, Alan R. and March, Salvatore T. and Park, Jinsoo and Ram, Sudha},
	month = mar,
	year = {2004},
	keywords = {business environment, creativity, design artifact, design science, experimental methods, information systems research methodologies, search strategies, technology infrastructure},
	pages = {75--105}
}

@article{eaddy_crosscutting_2008,
	title = {Do {Crosscutting} {Concerns} {Cause} {Defects}?},
	volume = {34},
	issn = {0098-5589},
	doi = {10.1109/TSE.2008.36},
	abstract = {There is a growing consensus that crosscutting concerns harm code quality. An example of a crosscutting concern is a functional requirement whose implementation is distributed across multiple software modules. We asked the question, "How much does the amount that a concern is crosscutting affect the number of defects in a program?" We conducted three extensive case studies to help answer this question. All three studies revealed a moderate to strong statistically significant correlation between the degree of scattering and the number of defects. This paper describes the experimental framework we developed to conduct the studies, the metrics we adopted and developed to measure the degree of scattering, the studies we performed, the efforts we undertook to remove experimental and other biases, and the results we obtained. In the process, we have formulated a theory that explains why increased scattering might lead to increased defects.},
	number = {4},
	journal = {IEEE Transactions on Software Engineering},
	author = {Eaddy, M. and Zimmermann, T. and Sherwood, K.D. and Garg, V. and Murphy, G.C. and Nagappan, N. and Aho, A.V.},
	month = jul,
	year = {2008},
	keywords = {code quality, Correlation and regression analysis, crosscutting concerns, data mining, Distribution Maintenance and Enhancement, metrics/measurement, Quality analysis and evaluation, Software Construction, software engineering, software modules, Software Quality/SQA, statistically significant correlation, User/Machine Systems, Validation},
	pages = {497--515},
	file = {IEEE Xplore Abstract Record:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/PE38E9GR/abs_all.html:text/html;IEEE Xplore Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/28Q2U5XM/Eaddy et al. - 2008 - Do Crosscutting Concerns Cause Defects.pdf:application/pdf}
}

@inproceedings{queiroz_does_2014,
	series = {{FOSD} '14},
	title = {Does feature scattering follow power-law distributions?: an investigation of five pre-processor-based systems},
	isbn = {978-1-4503-2980-4},
	shorttitle = {Does feature scattering follow power-law distributions?},
	url = {http://dl.acm.org/citation.cfm?doid=2660190.2662114},
	doi = {10.1145/2660190.2662114},
	urldate = {2015-07-06},
	booktitle = {Proceedings of the 6th {International} {Workshop} on {Feature}-{Oriented} {Software} {Development}},
	publisher = {ACM Press},
	author = {Queiroz, Rodrigo and Passos, Leonardo and Valente, Marco Tulio and Apel, Sven and Czarnecki, Krzysztof},
	year = {2014},
	pages = {23--29}
}

@inproceedings{sharma_does_2016,
	address = {New York, NY, USA},
	series = {{MSR} '16},
	title = {Does {Your} {Configuration} {Code} {Smell}?},
	url = {http://doi.acm.org/10.1145/2901739.2901761},
	doi = {10.1145/2901739.2901761},
	abstract = {Infrastructure as Code (IaC) is the practice of specifying computing system configurations through code, and managing them through traditional software engineering methods. The wide adoption of configuration management and increasing size and complexity of the associated code, prompt for assessing, maintaining, and improving the configuration code's quality. In this context, traditional software engineering knowledge and best practices associated with code quality management can be leveraged to assess and manage configuration code quality. We propose a catalog of 13 implementation and 11 design configuration smells, where each smell violates recommended best practices for configuration code. We analyzed 4,621 Puppet repositories containing 8.9 million lines of code and detected the cataloged implementation and design configuration smells. Our analysis reveals that the design configuration smells show 9\% higher average co-occurrence among themselves than the implementation configuration smells. We also observed that configuration smells belonging to a smell category tend to co-occur with configuration smells belonging to another smell category when correlation is computed by volume of identified smells. Finally, design configuration smell density shows negative correlation whereas implementation configuration smell density exhibits no correlation with the size of a configuration management system.},
	urldate = {2016-07-04},
	booktitle = {Proceedings of the 13th {International} {Conference} on {Mining} {Software} {Repositories}},
	publisher = {ACM},
	author = {Sharma, Tushar and Fragkoulis, Marios and Spinellis, Diomidis},
	year = {2016},
	keywords = {code quality, configuration smells, infrastructure as code, maintainability, technical debt},
	pages = {189--200},
	file = {ACM Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/4NXMQXBW/Sharma et al. - 2016 - Does Your Configuration Code Smell.pdf:application/pdf}
}

@article{lim_effects_1994,
	title = {Effects of reuse on quality, productivity, and economics},
	volume = {11},
	issn = {0740-7459},
	url = {http://ieeexplore.ieee.org/document/311048/},
	doi = {10.1109/52.311048},
	number = {5},
	urldate = {2016-11-15},
	journal = {IEEE Software},
	author = {Lim, W.C.},
	month = sep,
	year = {1994},
	pages = {23--30}
}

@article{sincero_efficient_2010,
	title = {Efficient extraction and analysis of preprocessor-based variability},
	volume = {46},
	issn = {0362-1340},
	url = {http://doi.acm.org/10.1145/1942788.1868300},
	doi = {10.1145/1942788.1868300},
	abstract = {The C Preprocessor (CPP) is the tool of choice for the implementation of variability in many large-scale configurable software projects. Linux, probably the most-configurable piece of software ever, employs more than 10,000 preprocessor variables for this purpose. However, this de-facto variability tends to be "hidden in the code"; which on the long term leads to variability defects, such as dead code or inconsistencies with respect to the intended (modeled) variability of the software. This calls for tool support for the efficient extraction of (and reasoning over) CPP-based variability. We suggest a novel approach to extract CPP-based variability. Our tool transforms CPP-based variability in O(n) complexity into a propositional formula that "mimics" all valid effects of conditional compilation and can be analyzed with standard SAT or BDD packages. Our evaluation results demonstrate the scalability and practicability of the approach. A dead-block-analysis on the complete Linux source tree takes less than 30 minutes; we thereby have revealed 60 dead blocks, 2 of which meanwhile have been confirmed as new (and long-lasting) bugs; the rest is still under investigation.},
	number = {2},
	urldate = {2013-03-08},
	journal = {SIGPLAN Not.},
	author = {Sincero, Julio and Tartler, Reinhard and Lohmann, Daniel and Schröder-Preikschat, Wolfgang},
	year = {2010},
	keywords = {conditional compilation, Linux, variability},
	pages = {33--42},
	file = {ACM Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/NTSVNKJF/Sincero et al. - 2010 - Efficient extraction and analysis of preprocessor-.pdf:application/pdf}
}

@phdthesis{mendonca_efficient_2009,
	address = {Waterloo},
	type = {{PhD} dissertation},
	title = {Efficient {Reasoning} {Techniques} for {Large} {Scale} {Feature} {Models}},
	school = {University of Waterloo},
	author = {Mendonça, Marcílio},
	year = {2009},
	file = {Efficient Reasoning Techniques for Large Scale Feature Models | Generative Software Development Lab:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/Q965U7AN/109.html:text/html}
}

@incollection{pirklbauer_empirical_2010,
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Empirical {Evaluation} of {Strategies} to {Detect} {Logical} {Change} {Dependencies}},
	copyright = {©2010 Springer-Verlag Berlin Heidelberg},
	isbn = {978-3-642-11265-2 978-3-642-11266-9},
	url = {http://link.springer.com/chapter/10.1007/978-3-642-11266-9_54},
	abstract = {Change impact analysis plays an immanent role in the maintenance and enhancement of software systems. There still exist many approaches to support change impact analysis. In the last years researchers try to utilize data in software repositories to gain findings for supporting miscellaneous aspects of software engineering, e.g. software evolution analysis or change impact analysis. In the context of change impact analysis, approaches (=strategies) try to detect logical dependencies among artifacts based on the version histories of files in the concurrent versioning system (e.g. CVS). They try to infer logical couplings of files (artifacts) based on co-changes (files which are frequently changed together). Based on these findings we want to contribute with the presentation of insights of deeper investigation of historical information in concurrent versioning systems in general. In this paper we have identified and described existing strategies to detect logical change couplings. These strategies will be illustrated by practical use cases. We have empirically evaluated these strategies based on versioning system repositories of two industrial projects. The analysis figures the absolute and relative contribution of dependency results per strategy. Furthermore we show overlappings of dependency results.},
	number = {5901},
	urldate = {2014-10-07},
	booktitle = {{SOFSEM} 2010: {Theory} and {Practice} of {Computer} {Science}},
	publisher = {Springer Berlin Heidelberg},
	author = {Pirklbauer, Guenter},
	editor = {Leeuwen, Jan van and Muscholl, Anca and Peleg, David and Pokorný, Jaroslav and Rumpe, Bernhard},
	month = jan,
	year = {2010},
	keywords = {change impact analysis, change prediction, Database Management, Data Storage Representation, data structures, logical change couplings, Logical change dependencies, mining software repositories, Programming Techniques, software engineering, Software Engineering/Programming and Operating Systems},
	pages = {651--662},
	file = {Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/757KH6J4/Pirklbauer - 2010 - Empirical Evaluation of Strategies to Detect Logic.pdf:application/pdf;Snapshot:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/8UEXFXMH/10.html:text/html}
}

@article{lemley_encouraging_1997,
	title = {Encouraging {Software} {Reuse}},
	volume = {49},
	issn = {00389765},
	url = {http://www.jstor.org/stable/1229298?origin=crossref},
	doi = {10.2307/1229298},
	number = {2},
	urldate = {2016-11-15},
	journal = {Stanford Law Review},
	author = {Lemley, Mark A. and O'Brien, David W.},
	month = jan,
	year = {1997},
	pages = {255}
}

@inproceedings{rowe_evaluating_1997,
	title = {Evaluating evolvability of computer based systems architectures-an ontological approach},
	booktitle = {Engineering of {Computer}-{Based} {Systems}, 1997. {Proceedings}., {International} {Conference} and {Workshop} on},
	author = {Rowe, D. and Leaney, J.},
	year = {1997},
	pages = {360--367},
	file = {Evaluating evolvability of computer based systems architectures - an ontological approach.pdf:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/MZ45DF39/Evaluating evolvability of computer based systems architectures - an ontological approach.pdf:application/pdf}
}

@inproceedings{schaefer_evaluating_2015,
	series = {{ICSR} '15},
	title = {Evaluating {Feature} {Change} {Impact} on {Multi}-product {Line} {Configurations} {Using} {Partial} {Information}},
	isbn = {978-3-319-14129-9 978-3-319-14130-5},
	url = {http://link.springer.com/10.1007/978-3-319-14130-5_1},
	urldate = {2015-06-30},
	booktitle = {Proceedings of the 14th {Conference} on {Software} {Reuse}},
	publisher = {Springer International Publishing},
	author = {Dintzner, Nicolas and Kulesza, Uirá and van Deursen, Arie and Pinzger, Martin},
	editor = {Schaefer, Ina and Stamelos, Ioannis},
	year = {2015},
	pages = {1--16}
}

@inproceedings{botterweck_evofm:_2010,
	series = {{PLEASE} '10},
	title = {{EvoFM}: feature-driven planning of product-line evolution},
	isbn = {978-1-60558-968-8},
	shorttitle = {{EvoFM}},
	url = {http://doi.acm.org/10.1145/1808937.1808941},
	doi = {10.1145/1808937.1808941},
	abstract = {Companies successfully applying product line approaches often follow a long-term strategy and need to plan product portfolios years ahead. For instance in the automotive industry, managers constantly make decisions about future product evolution, like "the LED tail lights will be introduced with the next facelift and the LED front lights two years later". With a raising number of features, feature changes, and evolution steps, a systematic approach for evolution planning becomes essential. However, there is only very little support for such evolution in model-based product line engineering so far. This paper presents an approach for extending model-driven product line engineering towards automated and tool-supported techniques for product line evolution. We provide a feature-based approach to model the variability over time and a catalogue of change operators for feature models.},
	urldate = {2013-09-09},
	booktitle = {Proceedings of the 2010 {ICSE} {Workshop} on {Product} {Line} {Approaches} in {Software} {Engineering}},
	publisher = {ACM},
	author = {Botterweck, Goetz and Pleuss, Andreas and Dhungana, Deepak and Polzer, Andreas and Kowalewski, Stefan},
	year = {2010},
	keywords = {feature modelling, model-driven product line engineering, software evolution},
	pages = {24--31},
	file = {ACM Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/96BFTKUM/Botterweck et al. - 2010 - EvoFM feature-driven planning of product-line evo.pdf:application/pdf}
}

@inproceedings{godfrey_evolution_2000,
	series = {{ICSM}'00},
	title = {Evolution in open source software: a case study},
	doi = {10.1109/ICSM.2000.883030},
	booktitle = {Proceedings of the {International} {Conference} on {Software} {Maintenance}},
	author = {Godfrey, M.W. and Tu, Qiang},
	year = {2000},
	keywords = {case study, commercially developed systems, development model, evolutionary narratives, large software systems, Linux operating system kernel, open source software, operating system kernels, software evolution, software maintenance, software prototyping, Unix},
	pages = {131--142}
}

@incollection{lotufo_evolution_2010,
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Evolution of the {Linux} {Kernel} {Variability} {Model}},
	copyright = {©2010 Springer-Verlag Berlin Heidelberg},
	isbn = {978-3-642-15578-9 978-3-642-15579-6},
	url = {http://link.springer.com/chapter/10.1007/978-3-642-15579-6_10},
	abstract = {Understanding the challenges faced by real projects in evolving variability models, is a prerequisite for providing adequate support for such undertakings. We study the evolution of a model describing features and configurations in a large product line—the Linux kernel variability model. We analyze this evolution quantitatively and qualitatively. Our primary finding is that the Linux kernel model appears to evolve surprisingly smoothly. In the analyzed period, the number of features had doubled, and still the structural complexity of the model remained roughly the same. Furthermore, we provide an in-depth look at the effect of the kernel’s development methodologies on the evolution of its model. We also include evidence about edit operations applied in practice, evidence of challenges in maintaining large models, and a range of recommendations (and open problems) for builders of modeling tools.},
	number = {6287},
	urldate = {2013-03-08},
	booktitle = {Software {Product} {Lines}: {Going} {Beyond}},
	publisher = {Springer Berlin Heidelberg},
	author = {Lotufo, Rafael and She, Steven and Berger, Thorsten and Czarnecki, Krzysztof and Wasowski, Andrzej},
	editor = {Bosch, Jan and Lee, Jaejoon},
	year = {2010},
	keywords = {Computer Communication Networks, Database Management, Information Storage and Retrieval, Information Systems and Communication Service, Information Systems Applications (incl.Internet), software engineering},
	pages = {136--150},
	file = {Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/Q5WTRU44/Lotufo et al. - 2010 - Evolution of the Linux Kernel Variability Model.pdf:application/pdf;Snapshot:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/77BPPGF2/10.html:text/html;Snapshot:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/GWDCFE4G/978-3-642-15579-6_10.html:text/html}
}

@article{white_evolving_2014,
	title = {Evolving {Feature} {Model} {Configurations} in {Software} {Product} {Lines}},
	volume = {87},
	issn = {0164-1212},
	url = {http://dx.doi.org/10.1016/j.jss.2013.10.010},
	doi = {10.1016/j.jss.2013.10.010},
	abstract = {The increasing complexity and cost of software-intensive systems has led developers to seek ways of reusing software components across development projects. One approach to increasing software reusability is to develop a software product-line (SPL), which is a software architecture that can be reconfigured and reused across projects. Rather than developing software from scratch for a new project, a new configuration of the SPL is produced. It is hard, however, to find a configuration of an SPL that meets an arbitrary requirement set and does not violate any configuration constraints in the SPL. Existing research has focused on techniques that produce a configuration of an SPL in a single step. Budgetary constraints or other restrictions, however, may require multi-step configuration processes. For example, an aircraft manufacturer may want to produce a series of configurations of a plane over a span of years without exceeding a yearly budget to add features. This paper provides three contributions to the study of multi-step configuration for SPLs. First, we present a formal model of multi-step SPL configuration and map this model to constraint satisfaction problems (CSPs). Second, we show how solutions to these SPL configuration problems can be automatically derived with a constraint solver by mapping them to CSPs. Moreover, we show how feature model changes can be mapped to our approach in a multi-step scenario by using feature model drift. Third, we present empirical results demonstrating that our CSP-based reasoning technique can scale to SPL models with hundreds of features and multiple configuration steps.},
	urldate = {2015-02-19},
	journal = {J. Syst. Softw.},
	author = {White, Jules and Galindo, José A. and Saxena, Tripti and Dougherty, Brian and Benavides, David and Schmidt, Douglas C.},
	month = jan,
	year = {2014},
	keywords = {feature model, Multi-step configuration, software product line},
	pages = {119--136}
}

@incollection{lopes_exastencils:_2014,
	address = {Cham},
	title = {{ExaStencils}: {Advanced} {Stencil}-{Code} {Engineering}},
	volume = {8806},
	isbn = {978-3-319-14312-5 978-3-319-14313-2},
	shorttitle = {{ExaStencils}},
	url = {http://link.springer.com/10.1007/978-3-319-14313-2_47},
	urldate = {2017-04-18},
	booktitle = {Euro-{Par} 2014: {Parallel} {Processing} {Workshops}},
	publisher = {Springer International Publishing},
	author = {Lengauer, Christian and Apel, Sven and Bolten, Matthias and Größlinger, Armin and Hannig, Frank and Köstler, Harald and Rüde, Ulrich and Teich, Jürgen and Grebhahn, Alexander and Kronawitter, Stefan and Kuckuk, Sebastian and Rittich, Hannah and Schmitt, Christian},
	editor = {Lopes, Luís and Žilinskas, Julius and Costan, Alexandru and Cascella, Roberto G. and Kecskemeti, Gabor and Jeannot, Emmanuel and Cannataro, Mario and Ricci, Laura and Benkner, Siegfried and Petit, Salvador and Scarano, Vittorio and Gracia, José and Hunold, Sascha and Scott, Stephen L. and Lankes, Stefan and Lengauer, Christian and Carretero, Jesús and Breitbart, Jens and Alexander, Michael},
	year = {2014},
	note = {DOI: 10.1007/978-3-319-14313-2\_47},
	pages = {553--564}
}

@inproceedings{zhou_extracting_2015,
	title = {Extracting {Configuration} {Knowledge} from {Build} {Files} with {Symbolic} {Analysis}},
	abstract = {Build    systems    contain    a    lot    of    configuration
knowledge   about   a   software   system,   such   as   under   which
conditions     specific     files     are     compiled.     Extracting     such
configuration  knowledge  is  important  for  many  tools  analyzing
highly-configurable  systems,  but  very  challenging  due  to  the
complex nature of build systems. We design an approach, based
on  SYMake,  that  symbolically  evaluates  Makefiles  and  extracts
configuration knowledge in terms of file presence conditions and
conditional  parameters.  We  implement  an  initial  prototype  and
demonstrate feasibility on small examples},
	booktitle = {Proceedings of the 3rd {International} {Workshop} on {Release} {Engineering} ({Releng})},
	publisher = {ACM Press},
	author = {Zhou, Shurui and Al-Kofahi, Jafar and Nguyen, Tien N. and Kaestner, Christian and Nadi, Sarah},
	month = may,
	year = {2015}
}

@inproceedings{dintzner_extracting_2013,
	series = {{VaMoS} '14},
	title = {Extracting feature model changes from the {Linux} kernel using {FMDiff}},
	isbn = {978-1-4503-2556-1},
	url = {http://dl.acm.org/citation.cfm?doid=2556624.2556631},
	doi = {10.1145/2556624.2556631},
	urldate = {2014-10-10},
	booktitle = {Proceedings of the {Eighth} {International} {Workshop} on {Variability} {Modelling} of {Software}-{Intensive} {Systems}},
	publisher = {ACM Press},
	author = {Dintzner, Nicolas and Van Deursen, Arie and Pinzger, Martin},
	year = {2013}
}

@inproceedings{sincero_facing_2010,
	address = {Paris, France},
	series = {{EuroSys} '10},
	title = {Facing the {Linux} 8000 {Feature} {Nightmare}},
	url = {http://www4.informatik.uni-erlangen.de/Publications/2010/sincero_tartler_eurosys-life.pdf},
	booktitle = {Proceedings of {ACM} {European} {Conference} on {Computer} {Systems}},
	author = {Sincero, Julio and Tartler, Reinhard and Egger, Christoph and Schröder-Preikschat, Wolfgang and Lohmann, Daniel},
	editor = {SIGOPS, ACM},
	year = {2010},
	keywords = {Configurability, Maintenance, Software engineering, System Software, VAMOS}
}

@inproceedings{rosenmuller_fame-dbms:_2008,
	series = {{SETMDM} '08},
	title = {{FAME}-{DBMS}: tailor-made data management solutions for embedded systems},
	isbn = {978-1-59593-964-7},
	shorttitle = {{FAME}-{DBMS}},
	doi = {10.1145/1385486.1385488},
	booktitle = {Proceedings of the 2008 {EDBT} workshop on {Software} engineering for tailor-made data management},
	publisher = {ACM Press},
	author = {Rosenmüller, Marko and Siegmund, Norbert and Schirmeier, Horst and Sincero, Julio and Apel, Sven and Leich, Thomas and Spinczyk, Olaf and Saake, Gunter},
	year = {2008}
}

@article{thompson_feature-based_1999,
	title = {Feature-based reverse engineering of mechanical parts},
	volume = {15},
	issn = {1042296X},
	url = {http://ieeexplore.ieee.org/document/744602/},
	doi = {10.1109/70.744602},
	number = {1},
	urldate = {2016-10-11},
	journal = {IEEE Transactions on Robotics and Automation},
	author = {Thompson, W.B. and Owen, J.C. and de St. Germain, H.J. and Stark, S.R. and Henderson, T.C.},
	month = feb,
	year = {1999},
	pages = {57--66}
}

@incollection{apel_featurec++:_2005,
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {{FeatureC}++: {On} the {Symbiosis} of {Feature}-{Oriented} and {Aspect}-{Oriented} {Programming}},
	volume = {3676},
	isbn = {978-3-540-29138-1},
	shorttitle = {{FeatureC}++},
	url = {http://www.springerlink.com/content/5dw90b201cq5w6wk/abstract/},
	urldate = {2012-08-21},
	booktitle = {Generative {Programming} and {Component} {Engineering}},
	publisher = {Springer Berlin / Heidelberg},
	author = {Apel, Sven and Leich, Thomas and Rosenmüller, Marko and Saake, Gunter},
	editor = {Glück, Robert and Lowry, Michael},
	year = {2005},
	keywords = {Computer Science},
	pages = {125--140},
	file = {SpringerLink Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/H46WJAER/Apel et al. - 2005 - FeatureC++ On the Symbiosis of Feature-Oriented a.pdf:application/pdf;SpringerLink Snapshot:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/DAXK8T6G/abstract.html:text/html}
}

@inproceedings{tartler_feature_2011,
	series = {{EuroSys} '11},
	title = {Feature consistency in compile-time-configurable system software: facing the linux 10,000 feature problem},
	isbn = {978-1-4503-0634-8},
	shorttitle = {Feature consistency in compile-time-configurable system software},
	url = {http://doi.acm.org/10.1145/1966445.1966451},
	doi = {10.1145/1966445.1966451},
	abstract = {Much system software can be configured at compile time to tailor it with respect to a broad range of supported hardware architectures and application domains. A good example is the Linux kernel, which provides more than 10,000 configurable features, growing rapidly. From the maintenance point of view, compile-time configurability imposes big challenges. The configuration model (the selectable features and their constraints as presented to the user) and the configurability that is actually implemented in the code have to be kept in sync, which, if performed manually, is a tedious and error-prone task. In the case of Linux, this has led to numerous defects in the source code, many of which are actual bugs. We suggest an approach to automatically check for configurability-related implementation defects in large-scale configurable system software. The configurability is extracted from its various implementation sources and examined for inconsistencies, which manifest in seemingly conditional code that is in fact unconditional. We evaluate our approach with the latest version of Linux, for which our tool detects 1,776 configurability defects, which manifest as dead/superfluous source code and bugs. Our findings have led to numerous source-code improvements and bug fixes in Linux: 123 patches (49 merged) fix 364 defects, 147 of which have been confirmed by the corresponding Linux developers and 20 as fixing a new bug.},
	urldate = {2013-03-08},
	booktitle = {Proceedings of the 6th {Conference} on {Computer} systems},
	publisher = {ACM},
	author = {Tartler, Reinhard and Lohmann, Daniel and Sincero, Julio and Schröder-Preikschat, Wolfgang},
	year = {2011},
	keywords = {configurability, Linux, maintenance, static analysis, VAMOS},
	pages = {47--60},
	file = {ACM Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/ZNG8HNPN/Tartler et al. - 2011 - Feature consistency in compile-time-configurable s.pdf:application/pdf}
}

@inproceedings{schobbens_feature_2006,
	title = {Feature {Diagrams}: {A} {Survey} and a {Formal} {Semantics}},
	isbn = {978-0-7695-2555-6},
	shorttitle = {Feature {Diagrams}},
	url = {http://ieeexplore.ieee.org/document/1704057/},
	doi = {10.1109/RE.2006.23},
	urldate = {2016-10-25},
	publisher = {IEEE},
	author = {Schobbens, P.-Y. and Heymans, P. and Trigaux, J.-C.},
	month = sep,
	year = {2006},
	pages = {139--148}
}

@article{classen_featured_2013,
	title = {Featured {Transition} {Systems}: {Foundations} for {Verifying} {Variability}-{Intensive} {Systems} and {Their} {Application} to {LTL} {Model} {Checking}},
	volume = {39},
	issn = {0098-5589, 1939-3520},
	shorttitle = {Featured {Transition} {Systems}},
	url = {http://ieeexplore.ieee.org/document/6389685/},
	doi = {10.1109/TSE.2012.86},
	number = {8},
	urldate = {2016-10-31},
	journal = {IEEE Transactions on Software Engineering},
	author = {Classen, Andreas and Cordy, Maxime and Schobbens, Pierre-Yves and Heymans, Patrick and Legay, Axel and Raskin, Jean-Francois},
	month = aug,
	year = {2013},
	pages = {1069--1089}
}

@article{thum_featureide:_2014,
	title = {{FeatureIDE}: {An} {Extensible} {Framework} for {Feature}-{Oriented} {Software} {Development}},
	volume = {79},
	number = {0},
	journal = {Science of Computer Programming},
	author = {Thüm, Thomas and Kaestner, Christian and Benduhn, Fabian and Meinicke, Jens and Saake, Gunter and Leich, Thomas},
	year = {2014},
	pages = {70--85}
}

@article{dit_feature_2013,
	title = {Feature location in source code: a taxonomy and survey},
	volume = {25},
	copyright = {Copyright © 2011 John Wiley \& Sons, Ltd.},
	issn = {2047-7481},
	shorttitle = {Feature location in source code},
	url = {http://onlinelibrary.wiley.com/doi/10.1002/smr.567/abstract},
	doi = {10.1002/smr.567},
	abstract = {Feature location is the activity of identifying an initial location in the source code that implements functionality in a software system. Many feature location techniques have been introduced that automate some or all of this process, and a comprehensive overview of this large body of work would be beneficial to researchers and practitioners. This paper presents a systematic literature survey of feature location techniques. Eighty-nine articles from 25 venues have been reviewed and classified within the taxonomy in order to organize and structure existing work in the field of feature location. The paper also discusses open issues and defines future directions in the field of feature location. Copyright © 2011 John Wiley \& Sons, Ltd.},
	number = {1},
	urldate = {2014-10-24},
	journal = {Journal of Software: Evolution and Process},
	author = {Dit, Bogdan and Revelle, Meghan and Gethers, Malcom and Poshyvanyk, Denys},
	month = jan,
	year = {2013},
	keywords = {concept location, feature location, program comprehension, software maintenance and evolution},
	pages = {53--95},
	file = {Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/Q8E83EZC/Dit et al. - 2013 - Feature location in source code a taxonomy and su.pdf:application/pdf;Snapshot:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/RQ3QN45N/full.html:text/html}
}

@incollection{acher_feature_2012,
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Feature {Model} {Differences}},
	copyright = {©2012 Springer-Verlag Berlin Heidelberg},
	isbn = {978-3-642-31094-2 978-3-642-31095-9},
	url = {http://link.springer.com/chapter/10.1007/978-3-642-31095-9_41},
	abstract = {Feature models are a widespread means to represent commonality and variability in software product lines. As is the case for other kinds of models, computing and managing feature model differences is useful in various real-world situations. In this paper, we propose a set of novel differencing techniques that combine syntactic and semantic mechanisms, and automatically produce meaningful differences. Practitioners can exploit our results in various ways: to understand, manipulate, visualize and reason about differences. They can also combine them with existing feature model composition and decomposition operators. The proposed automations rely on satisfiability algorithms. They come with a dedicated language and a comprehensive environment. We illustrate and evaluate the practical usage of our techniques through a case study dealing with a configurable component framework.},
	number = {7328},
	urldate = {2015-02-14},
	booktitle = {Advanced {Information} {Systems} {Engineering}},
	publisher = {Springer Berlin Heidelberg},
	author = {Acher, Mathieu and Heymans, Patrick and Collet, Philippe and Quinton, Clément and Lahire, Philippe and Merle, Philippe},
	editor = {Ralyté, Jolita and Franch, Xavier and Brinkkemper, Sjaak and Wrycza, Stanislaw},
	year = {2012},
	keywords = {Artificial Intelligence (incl. Robotics), Computer Appl. in Administrative Data Processing, Database Management, Feature models, Information Systems and Communication Service, Information Systems Applications (incl. Internet), Model Differences, Model management, software engineering},
	pages = {629--645},
	file = {Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/AD7APPWM/Acher et al. - 2012 - Feature Model Differences.pdf:application/pdf;Snapshot:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/KMVG6V4N/978-3-642-31095-9_41.html:text/html}
}

@inproceedings{rothberg_feature_2016,
	address = {New York, NY, USA},
	series = {{VaMoS} '16},
	title = {Feature {Models} in {Linux}: {From} {Symbols} to {Semantics}},
	isbn = {978-1-4503-4019-9},
	shorttitle = {Feature {Models} in {Linux}},
	url = {http://doi.acm.org/10.1145/2866614.2866624},
	doi = {10.1145/2866614.2866624},
	abstract = {Linux is a highly configurable operating-system kernel which has been widely studied in the context of software product lines over the past years. Understanding the challenges and perils of evolving and maintaining feature models of the size of Linux is crucial to provide the right tools for development today and to direct future research. Unfortunately, previous studies show contradictory observations when analyzing the evolution of Linux feature models. We explain how peculiarities of the feature models of the Linux kernel lead to those differing observations, and show how the results can be re-aligned. Moreover, our findings also demonstrate that symbolic differencing on feature models used by researchers so far has limited value, depending on the use case. We show how the limitations can be addressed by means of semantic differencing, and ironically invalidate the results we sought to re-align.},
	urldate = {2016-09-05},
	booktitle = {Proceedings of the {Tenth} {International} {Workshop} on {Variability} {Modelling} of {Software}-intensive {Systems}},
	publisher = {ACM},
	author = {Rothberg, Valentin and Dintzner, Nicolas and Ziegler, Andreas and Lohmann, Daniel},
	year = {2016},
	keywords = {CADOS, configurability, Feature models, Kconfig, Linux},
	pages = {65--72},
	file = {ACM Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/AKUCIE57/Rothberg et al. - 2016 - Feature Models in Linux From Symbols to Semantics.pdf:application/pdf}
}

@techreport{kang_feature-oriented_1990,
	title = {Feature-{Oriented} {Domain} {Analysis} ({FODA}) {Feasibility} {Study}},
	abstract = {Successful Software reuse requires the systematic discovery and exploitation of commonality across related software systems. By examining related software systems and the underlying theory of the class of systems they represent, domain analysis can provide a generic description of the requirements of that class of systems and a set of approaches for their implementation. This report will establish methods for performing a domain analysis and describe the products of the domain analysis process. To illustrate the application of domain analysis to a representative class of software systems, this report will provide a domain analysis of window management system software.},
	urldate = {2012-07-19},
	institution = {Software Engineering Institute, Carnegie Mellon University},
	author = {Kang, Kyo C. and Cohen, Sholom G. and Hess, James A. and Novak, William E. and Peterson, A. S.},
	year = {1990},
	keywords = {*REUSABLE EQUIPMENT, *SOFTWARE ENGINEERING, *SYSTEMS ANALYSIS, COMMONALITY, COMPUTER PROGRAMMING AND SOFTWARE, COMPUTER PROGRAMS, FEASIBILITY STUDIES, MANAGEMENT PLANNING AND CONTROL, PE63752F, REQUIREMENTS, WINDOWS},
	file = {DTIC Snapshot:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/7SDB3537/oai.html:text/html;Feature-Oriented Domain Analysis (FODA) Feasibility Study.pdf:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/A2AC5AZK/Feature-Oriented Domain Analysis (FODA) Feasibility Study.pdf:application/pdf}
}

@article{kang_feature-oriented_2002,
	title = {Feature-oriented product line engineering},
	volume = {19},
	issn = {0740-7459},
	doi = {10.1109/MS.2002.1020288},
	abstract = {The feature-oriented reuse method analyzes and models a product line's commonalities and differences in terms of product features and uses the analysis results to develop architectures and components. The article illustrates, with a home integration system example, how FORM brings efficiency into product line development.},
	number = {4},
	journal = {Software, IEEE},
	author = {Kang, K.C. and Lee, Jaejoon and Donohoe, P.},
	month = aug,
	year = {2002},
	keywords = {commonalities;, development, differences;, engineering;, feature-oriented, FORM;, home, integration, line, management;, method;, product, reusability;, reuse, software, system;},
	pages = {58 -- 65},
	file = {IEEE Xplore Abstract Record:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/REQFI8TF/stamp.html:text/html;IEEE Xplore Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/JNB78IGH/Kang et al. - 2002 - Feature-oriented product line engineering.pdf:application/pdf}
}

@incollection{goos_feature-oriented_1997,
	address = {Berlin, Heidelberg},
	title = {Feature-oriented programming: {A} fresh look at objects},
	volume = {1241},
	isbn = {978-3-540-63089-0 978-3-540-69127-3},
	shorttitle = {Feature-oriented programming},
	url = {http://link.springer.com/10.1007/BFb0053389},
	urldate = {2016-12-19},
	booktitle = {{ECOOP}'97 — {Object}-{Oriented} {Programming}},
	publisher = {Springer Berlin Heidelberg},
	author = {Prehofer, Christian},
	editor = {Goos, Gerhard and Hartmanis, Juris and van Leeuwen, Jan and Akşit, Mehmet and Matsuoka, Satoshi},
	year = {1997},
	pages = {419--443}
}

@inproceedings{batory_feature-oriented_2004,
	series = {{ICSE} '04},
	title = {Feature-{Oriented} {Programming} and the {AHEAD} {Tool} {Suite}},
	isbn = {0-7695-2163-0},
	url = {http://dl.acm.org/citation.cfm?id=998675.999478},
	abstract = {Feature Oriented Programming (FOP) is an emerging paradigmfor application synthesis, analysis, and optimization. Atarget application is specified declaratively as a set of features,like many consumer products (e.g., personal computers,automobiles). FOP technology translates suchdeclarative specifications into efficient programs.},
	urldate = {2013-02-11},
	booktitle = {Proceedings of the 26th {International} {Conference} on {Software} {Engineering}},
	publisher = {IEEE Computer Society},
	author = {Batory, Don},
	year = {2004},
	pages = {702--703},
	file = {ACM Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/KK4FU6QQ/Batory - 2004 - Feature-Oriented Programming and the AHEAD Tool Su.pdf:application/pdf}
}

@inproceedings{liu_feature_2006,
	address = {New York, NY, USA},
	series = {{ICSE} '06},
	title = {Feature oriented refactoring of legacy applications},
	isbn = {1-59593-375-1},
	url = {http://doi.acm.org/10.1145/1134285.1134303},
	doi = {10.1145/1134285.1134303},
	abstract = {Feature oriented refactoring (FOR) is the process of decomposinga program into features, where a feature is an increment in programfunctionality. We develop a theory of FOR that relates code refac-toring to algebraic factoring. Our theory explains relationshipsbetween features and their implementing modules, and why fea-tures in different programs of a product-line can have differentimplementations. We describe a tool and refactoring methodologybased on our theory, and present a validating case study.},
	urldate = {2012-07-25},
	booktitle = {Proceedings of the 28th international conference on {Software} engineering},
	publisher = {ACM},
	author = {Liu, Jia and Batory, Don and Lengauer, Christian},
	year = {2006},
	keywords = {feature interactions, features, product lines, program algebra, program synthesis, refactoring},
	pages = {112--121},
	file = {ACM Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/J35KRDKU/Liu et al. - 2006 - Feature oriented refactoring of legacy application.pdf:application/pdf;ACM Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/GUCM949P/Liu et al. - 2006 - Feature oriented refactoring of legacy application.pdf:application/pdf}
}

@inproceedings{passos_feature-oriented_2013,
	address = {New York, NY, USA},
	series = {{VaMoS} '13},
	title = {Feature-oriented {Software} {Evolution}},
	isbn = {978-1-4503-1541-8},
	url = {http://doi.acm.org/10.1145/2430502.2430526},
	doi = {10.1145/2430502.2430526},
	abstract = {In this paper, we develop a vision of software evolution based on a feature-oriented perspective. From the fact that features provide a common ground to all stakeholders, we derive a hypothesis that changes can be effectively managed in a feature-oriented manner. Assuming that the hypothesis holds, we argue that feature-oriented software evolution relying on automatic traceability, analyses, and recommendations reduces existing challenges in understanding and managing evolution. We illustrate these ideas using an automotive example and raise research questions for the community.},
	urldate = {2015-01-22},
	booktitle = {Proceedings of the 7th {International} {Workshop} on {Variability} {Modelling} of {Software}-intensive {Systems}},
	publisher = {ACM},
	author = {Passos, Leonardo and Czarnecki, Krzysztof and Apel, Sven and Wasowski, Andrzej and Kästner, Christian and Guo, Jianmei},
	year = {2013},
	keywords = {analysis, feature-oriented development, recommendation, software evolution, traceability},
	pages = {17:1--17:8}
}

@incollection{hutchison_feature--code_2010,
	address = {Berlin, Heidelberg},
	title = {Feature-to-{Code} {Mapping} in {Two} {Large} {Product} {Lines}},
	volume = {6287},
	isbn = {978-3-642-15578-9 978-3-642-15579-6},
	url = {http://link.springer.com/10.1007/978-3-642-15579-6_48},
	urldate = {2015-07-30},
	booktitle = {Software {Product} {Lines}: {Going} {Beyond}},
	publisher = {Springer Berlin Heidelberg},
	author = {Berger, Thorsten and She, Steven and Lotufo, Rafael and Czarnecki, Krzysztof and Wąsowski, Andrzej},
	editor = {Hutchison, David and Kanade, Takeo and Kittler, Josef and Kleinberg, Jon M. and Mattern, Friedemann and Mitchell, John C. and Naor, Moni and Nierstrasz, Oscar and Pandu Rangan, C. and Steffen, Bernhard and Sudan, Madhu and Terzopoulos, Demetri and Tygar, Doug and Vardi, Moshe Y. and Weikum, Gerhard and Bosch, Jan and Lee, Jaejoon},
	year = {2010},
	pages = {498--499}
}

@inproceedings{dintzner_fever:_2016,
	address = {New York, NY, USA},
	series = {{MSR} '16},
	title = {{FEVER}: {Extracting} {Feature}-oriented {Changes} from {Commits}},
	isbn = {978-1-4503-4186-8},
	shorttitle = {{FEVER}},
	url = {http://doi.acm.org/10.1145/2901739.2901755},
	doi = {10.1145/2901739.2901755},
	abstract = {The study of the evolution of highly configurable systems requires a thorough understanding of thee core ingredients of such systems: (1) the underlying variability model; (2) the assets that together implement the configurable features; and (3) the mapping from variable features to actual assets. Unfortunately, to date no systematic way to obtain such information at a sufficiently fine grained level exists. To remedy this problem we propose FEVER and its instantiation for the Linux kernel. FEVER extracts detailed information on changes in variability models (KConfig files), assets (preprocessor based C code), and mappings (Makefiles). We describe how FEVER works, and apply it to several releases of the Linux kernel. Our evaluation on 300 randomly selected commits, from two different releases, shows our results are accurate in 82.6\% of the commits. Furthermore, we illustrate how the populated FEVER graph database thus obtained can be used in typical Linux engineering tasks.},
	urldate = {2016-07-21},
	booktitle = {Proceedings of the 13th {International} {Conference} on {Mining} {Software} {Repositories}},
	publisher = {ACM},
	author = {Dintzner, Nicolas and van Deursen, Arie and Pinzger, Martin},
	year = {2016},
	keywords = {co-evolution, feature, highly variable systems, variability},
	pages = {85--96},
	file = {ACM Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/HQKAWJZT/Dintzner et al. - 2016 - FEVER Extracting Feature-oriented Changes from Co.pdf:application/pdf}
}

@inproceedings{fluri_fine-grained_2005,
	title = {Fine-grained analysis of change couplings},
	doi = {10.1109/SCAM.2005.14},
	abstract = {In software evolution analysis, many approaches analyze release history data available through versioning systems. The recent investigations of CVS data have shown that commonly committed files highlight their change couplings. However, CVS stores modifications on the basis of text but does not track structural changes, such as the insertion, removing, or modification of methods or classes. A detailed analysis whether change couplings are caused by source code couplings or by other textual modifications, such as updates in license terms, is not performed by current approaches. The focus of this paper is on adding structural change information to existing release history data. We present an approach that uses the structure compare services shipped with the Eclipse IDE to obtain the corresponding finegrained changes between two subsequent versions of any Java class. This information supports filtering those change couplings which result from structural changes. So we can distill the causes for change couplings along releases and filter out those that are structurally relevant. The first validation of our approach with a medium-sized open source software system showed that a reasonable amount of change couplings are not caused by source code changes.},
	booktitle = {Fifth {IEEE} {International} {Workshop} on {Source} {Code} {Analysis} and {Manipulation}, 2005},
	author = {Fluri, B. and Gall, H.C. and Pinzger, M.},
	month = sep,
	year = {2005},
	keywords = {change coupling filtering, computer architecture, configuration management, data analysis, Eclipse IDE, fine-grained analysis, History, Informatics, Information filtering, Information filters, Java, Java class, Licenses, Performance analysis, software evolution analysis, Software prototyping, software systems, source code couplings},
	pages = {66--74},
	file = {IEEE Xplore Abstract Record:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/FUZ2QA56/abs_all.html:text/html;IEEE Xplore Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/DPK4U97N/Fluri et al. - 2005 - Fine-grained analysis of change couplings.pdf:application/pdf}
}

@article{kang_form:_1998,
	title = {{FORM}: {A} feature-oriented reuse method with domain-specific reference architectures},
	volume = {5},
	issn = {1022-7091},
	shorttitle = {{FORM}},
	url = {http://www.springerlink.com/content/v6901t52316r1350/abstract/},
	doi = {10.1023/A:1018980625587},
	abstract = {Systematic discovery and exploitation of commonality across related software systems is a fundamental technical requirement for achieving successful software reuse. By examining a class/family of related systems and the commonality underlying those systems, it is possible to obtain a set of reference models, i.e., software architectures and components needed for implementing applications in the class. FORM (Feature-;Oriented Reuse Method) supports development of such reusable architectures and components (through a process called the “domain engineering”) and development of applications using the domain artifacts produced from the domain engineering. FORM starts with an analysis of commonality among applications in a particular domain in terms of services, operating environments, domain technologies, and implementation techniques. The model constructed during the analysis is called a “feature” model, and it captures commonality as an AND/OR graph, where AND nodes indicate mandatory features and OR nodes indicate alternative features selectable for different applications. Then, this model is used to define parameterized reference architectures and appropriate reusable components instantiatable during application development. Architectures are defined from three different viewpoints (subsystem, process, and module) and have intimate association with the features. The subsystem architecture is used to package service features and allocate them to different computers in a distributed environment. Each subsystem is further decomposed into processes considering the operating environment features. Modules are defined based on the features on domain technology and implementation techniques. These architecture models that represent an architecture at different levels of abstraction are derived from the feature hierarchy captured in the feature model. Modules serve as basis for creating reusable components, and their specification defines how they are integrated into the application (e.g., as-;is integration of pre-;coded component, instantiation of parameterized templates, and filling-;in skeletal codes). Our experiences have shown that for the electronic bulletin board and the private branch exchange (PBX) domains, “features” make up for a common domain language and the main communication medium among application users and developers. Thus, the feature model well represents a “decision space” of software development, and is a good starting point for identifying candidate reusable components.},
	number = {1},
	urldate = {2012-09-06},
	journal = {Annals of Software Engineering},
	author = {Kang, Kyo and Kim, Sajoong and Lee, Jaejoon and Kim, Kijoo and Shin, Euiseob and Huh, Moonhang},
	year = {1998},
	keywords = {Computer Science},
	pages = {143--168},
	file = {SpringerLink Snapshot:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/ERQ6AAP3/abstract.html:text/html}
}

@book{ganter_formal_2012,
	title = {Formal concept analysis: mathematical foundations},
	publisher = {Springer Science \& Business Media},
	author = {Ganter, Bernhard and Wille, Rudolf},
	year = {2012}
}

@techreport{she_formal_2010,
	address = {Waterloo (ON) Canada},
	type = {Technical {Note}},
	title = {Formal {Semantics} of the {Kconfig} {Language}},
	url = {http://gsd.uwaterloo.ca/sites/default/files/kconfig_semantics.pdf},
	abstract = {The Kconfig language defines a set of symbols that are assigned a value in a configuration. We describe the semantics of the Kconfig language according to the behaviour exhibited in the xconfig configurator. We assume an abstract syntax representation for concepts in the Kconfig language and delegate the details of the translation from concrete to abstract syntaxes to a later document.},
	urldate = {2015-01-30},
	institution = {University of Waterloo},
	author = {She, Steven and Berger, Thorsten},
	year = {2010},
	file = {Formal Semantics of the Kconfig Language | Generative Software Development Lab:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/RCUTTUD3/274.html:text/html}
}

@article{makar_formate_1975,
	title = {Formate assay in body fluids: application in methanol poisoning},
	volume = {13},
	issn = {0006-2944},
	shorttitle = {Formate assay in body fluids},
	language = {ENG},
	number = {2},
	journal = {Biochemical Medicine},
	author = {Makar, A. B. and McMartin, K. E. and Palese, M. and Tephly, T. R.},
	month = jun,
	year = {1975},
	pmid = {1},
	keywords = {Aldehyde Oxidoreductases, Animals, Body Fluids, Carbon Dioxide, Formates, Haplorhini, Humans, Hydrogen-Ion Concentration, Kinetics, Methanol, Methods, Pseudomonas},
	pages = {117--126}
}

@article{makar_formate_1975-1,
	title = {Formate assay in body fluids: application in methanol poisoning},
	volume = {13},
	issn = {0006-2944},
	shorttitle = {Formate assay in body fluids},
	language = {ENG},
	number = {2},
	journal = {Biochemical Medicine},
	author = {Makar, A. B. and McMartin, K. E. and Palese, M. and Tephly, T. R.},
	month = jun,
	year = {1975},
	pmid = {1},
	keywords = {Aldehyde Oxidoreductases, Animals, Body Fluids, Carbon Dioxide, Formates, Haplorhini, Humans, Hydrogen-Ion Concentration, Kinetics, Methanol, Methods, Pseudomonas},
	pages = {117--126}
}

@article{borgelt_frequent_2012,
	title = {Frequent item set mining},
	volume = {2},
	issn = {19424787},
	url = {http://doi.wiley.com/10.1002/widm.1074},
	doi = {10.1002/widm.1074},
	number = {6},
	urldate = {2015-08-25},
	journal = {Wiley Interdisciplinary Reviews: Data Mining and Knowledge Discovery},
	author = {Borgelt, Christian},
	month = nov,
	year = {2012},
	pages = {437--456}
}

@incollection{czarnecki_generative_2002,
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Generative {Programming} for {Embedded} {Software}: {An} {Industrial} {Experience} {Report}},
	copyright = {©2002 Springer-Verlag Berlin Heidelberg},
	isbn = {978-3-540-44284-4 978-3-540-45821-0},
	url = {http://link.springer.com/chapter/10.1007/3-540-45821-2_10},
	abstract = {Physical products come in many variants, and so does the software embedded in them. The software embedded in a product variant usually has to be optimized to fit its limited memory and computing power. Generative programming is well suited for developing embedded software since it allows us to automatically produce variants of embedded software optimized for specific products. This paper reports on our experience in applying generative programming in the embedded domain. We propose an extended feature modeling notation, discuss tool support for feature modeling, describe a domain-independent system configuration editor, and comment on the applicability of static configuration in the area of embedded systems.},
	number = {2487},
	urldate = {2013-04-22},
	booktitle = {Generative {Programming} and {Component} {Engineering}},
	publisher = {Springer Berlin Heidelberg},
	author = {Czarnecki, Krzysztof and Bednasch, Thomas and Unger, Peter and Eisenecker, Ulrich},
	editor = {Batory, Don and Consel, Charles and Taha, Walid},
	month = jan,
	year = {2002},
	keywords = {Computer Appl. in Administrative Data Processing, Management of Computing and Information Systems, Programming Languages, Compilers, Interpreters, Programming Techniques, software engineering},
	pages = {156--172},
	file = {Snapshot:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/3JKNSI6U/3-540-45821-2_10.html:text/html}
}

@incollection{czarnecki_generative_2002-1,
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Generative {Programming}: {Methods}, {Techniques}, and {Applications} {Tutorial} {Abstract}},
	volume = {2319},
	isbn = {978-3-540-43483-2},
	shorttitle = {Generative {Programming}},
	url = {http://www.springerlink.com/content/y0tn8d2gn6u6u6aa/abstract/},
	abstract = {Today’s software engineering practices are aimed at developing single systems. There are attempts to achieve reuse through object- and component-based technologies with two specific goals: to cut development costs, and time-to-market and to improve quality. But current research and practical experience suggest that only moving from the single system engineering to the system-family engineering approach can bring significant progress with respect to these goals [ 4 , 8 , 10 ].},
	urldate = {2012-08-01},
	booktitle = {Software {Reuse}: {Methods}, {Techniques}, and {Tools}},
	publisher = {Springer Berlin / Heidelberg},
	author = {Czarnecki, Krzysztof},
	editor = {Gacek, Cristina},
	year = {2002},
	keywords = {Computer Science},
	pages = {477--503},
	file = {SpringerLink Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/HA6PV5DD/Czarnecki - 2002 - Generative Programming Methods, Techniques, and A.pdf:application/pdf;SpringerLink Snapshot:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/DETC9HZN/abstract.html:text/html}
}

@incollection{muthig_generic_2003,
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Generic {Implementation} of {Product} {Line} {Components}},
	volume = {2591},
	isbn = {978-3-540-00737-1},
	url = {http://www.springerlink.com/content/fblxed399h81vx73/abstract/},
	abstract = {An argument pro component-based software development is the idea of constructing software systems by assembling preexisting components instead of redeveloping similar or identical functionality always from scratch. Unfortunately, integrating existing components practically means adaptation and use rather than use only, which makes an ideal component-based development hard to realize in practice. Product line engineering, however, tackles this problem by making components as generic as needed for a particular product family and thus allows component reuse. Such a component covers variabilities and thus its implementation must consider variabilities as well. In this paper, we describe a process for implementing generic product line components and give an overview of variability mechanisms at the implementation level, illustrated by a running example, a generic test component.},
	urldate = {2012-07-03},
	booktitle = {Objects, {Components}, {Architectures}, {Services}, and {Applications} for a {Networked} {World}},
	publisher = {Springer Berlin / Heidelberg},
	author = {Muthig, Dirk and Patzke, Thomas},
	editor = {Aksit, Mehmet and Mezini, Mira and Unland, Rainer},
	year = {2003},
	keywords = {Computer Science},
	pages = {313--329},
	file = {SpringerLink Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/FRN66FA8/Muthig and Patzke - 2003 - Generic Implementation of Product Line Components.pdf:application/pdf;SpringerLink Snapshot:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/M9E4IVB8/abstract.html:text/html}
}

@article{batory_genesis:_1988,
	title = {{GENESIS}: an extensible database management system},
	volume = {14},
	issn = {00985589},
	shorttitle = {{GENESIS}},
	url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=9057},
	doi = {10.1109/32.9057},
	number = {11},
	urldate = {2016-01-10},
	journal = {IEEE Transactions on Software Engineering},
	author = {Batory, D.S. and Barnett, J.R. and Garza, J.F. and Smith, K.P. and Tsukuda, K. and Twichell, B.C. and Wise, T.E.},
	year = {1988},
	pages = {1711--1730}
}

@article{clements_getting_2006,
	title = {Getting there from here: a roadmap for software product line adoption},
	volume = {49},
	issn = {00010782},
	shorttitle = {Getting there from here},
	url = {http://portal.acm.org/citation.cfm?doid=1183236.1183261},
	doi = {10.1145/1183236.1183261},
	number = {12},
	urldate = {2016-11-15},
	journal = {Communications of the ACM},
	author = {Clements, Paul C. and Jones, Lawrence G. and McGregor, John D. and Northrop, Linda M.},
	month = dec,
	year = {2006},
	pages = {33}
}

@book{abran_guide_2014,
	title = {Guide to the software engineering body of knowledge},
	isbn = {978-0-7695-5166-1},
	shorttitle = {{SWEBOK}},
	number = {3.0},
	publisher = {IEEE Computer Society},
	author = {Abran, Alain and Bourque, Pierre and Dupuis, Robert and Moore, James},
	year = {2014}
}

@inproceedings{cubranic_hipikat:_2003,
	address = {Washington, DC, USA},
	series = {{ICSE} '03},
	title = {Hipikat: {Recommending} {Pertinent} {Software} {Development} {Artifacts}},
	isbn = {978-0-7695-1877-0},
	shorttitle = {Hipikat},
	url = {http://dl.acm.org/citation.cfm?id=776816.776866},
	abstract = {A newcomer to a software project must typically come up-to-speed on a large, varied amount of information about the project before becoming productive. Assimilating this information in the open-source context is difficult because a newcomer cannot rely on the mentoring approach that is commonly used in traditional software developments. To help a newcomer to an open-source project become productive faster, we propose Hipikat, a tool that forms an implicit group memory from the information stored in a project's archives, and that recommends artifacts from the archives that are relevant to a task that a newcomer is trying to perform. To investigate this approach, we have instantiated the Hipikat tool for the Eclipse open-source project. In this paper, we describe the Hipikat tool, we report on a qualitative study conducted with a Hipikat mock-up on a medium-sized in-house project, and we report on a case study in which Hipikat recommendations were evaluated for a task on Eclipse.},
	urldate = {2017-06-22},
	booktitle = {Proceedings of the 25th {International} {Conference} on {Software} {Engineering}},
	publisher = {IEEE Computer Society},
	author = {Čubranić, Davor and Murphy, Gail C.},
	year = {2003},
	pages = {408--418},
	file = {ACM Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/UWR8GGJ3/Čubranić and Murphy - 2003 - Hipikat Recommending Pertinent Software Developme.pdf:application/pdf}
}

@inproceedings{tian_identifying_2012,
	series = {{ICSE} '12},
	title = {Identifying {Linux} {Bug} {Fixing} {Patches}},
	isbn = {978-1-4673-1067-3},
	url = {http://dl.acm.org/citation.cfm?id=2337223.2337269},
	booktitle = {Proceedings of the 34th {International} {Conference} on {Software} {Engineering}},
	publisher = {IEEE Press},
	author = {Tian, Yuan and Lawall, Julia and Lo, David},
	year = {2012},
	pages = {386--396}
}

@incollection{kastner_integrating_2008,
	title = {Integrating {Compositional} and {Annotative} {Approaches} for {Product} {Line} {Engineering}},
	isbn = {MIP-0804},
	url = {http://taha.e.twiki.net/twiki/pub/WG211/M8Schedule/Kaestner_M8_slides.pdf},
	urldate = {2012-07-31},
	booktitle = {Workshop on {Modularization}, {Composition}, and {Generative} {Techniques} for {Product} {Line} {Engineering}, {Proceedings}},
	publisher = {Department of Informatics and Mathematics, University of Passau},
	author = {Kästner, C. and Apel, S.},
	year = {2008},
	pages = {35--40},
	file = {Integrating compositional and annotative approaches for product line engineering.pdf:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/2W3EABPU/Integrating compositional and annotative approaches for product line engineering.pdf:application/pdf}
}

@inproceedings{griss_integrating_1998,
	series = {{ICSR}'98},
	title = {Integrating feature modeling with the {RSEB}},
	url = {http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=685732},
	urldate = {2012-07-04},
	booktitle = {Proceedings of the {Fifth} {International} {Conference} on {Software} {Reuse}},
	publisher = {IEEE Computer Society Press},
	author = {Griss, M. L. and Favaro, J. and d'Alessandro, M.},
	year = {1998},
	pages = {76--85},
	file = {00685732.pdf:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/R43I5X9E/00685732.pdf:application/pdf}
}

@inproceedings{li_interfaces_2002,
	series = {{ASE} '02},
	title = {Interfaces for {Modular} {Feature} {Verification}},
	isbn = {0-7695-1736-6},
	abstract = {Feature-oriented programming organizes programs around features rather than objects, thus better supporting extensible, product-line architectures. Programming languages increasingly support this style of programming, but programmers get little support from verification tools. Ideally, programmers should be able to verify features independently of each other and use automated compositional reasoning techniques to infer properties of a system from properties of its features. Achieving this requires carefully designed interfaces: they must hold sufficient information to enable compositional verification, yet tools should be able to generate this information automatically because experience indicates programmers cannot or will not provide it manually. We present a model of interfaces that supports automated, compositional, feature-oriented model checking. To demonstrate their utility, we automatically detect the feature-interaction problems originally found manually by Robert Hall in an email suite case study.},
	urldate = {2014-02-17},
	booktitle = {Proc. of the 17th {IEEE} {International} {Conference} on {Automated} {Software} {Engineering}},
	publisher = {IEEE Computer Society},
	author = {Li, Harry C. and Krishnamurthi, Shriram and Fisler, Kathi},
	month = sep,
	year = {2002},
	pages = {195--}
}

@inproceedings{merlo_investigating_2002,
	series = {{COMPSAC} '02},
	title = {Investigating large software system evolution: the {Linux} kernel},
	shorttitle = {Investigating large software system evolution},
	doi = {10.1109/CMPSAC.2002.1045038},
	abstract = {Large multi-platform, multi-million lines of codes software systems evolve to cope with new platform or to meet user ever changing needs. While there has been several studies focused on the similarity of code fragments or modules, few studies addressed the need to monitor the overall system evolution. Meanwhile, the decision to evolve or to re-factor a large software system needs to be supported by high level information, representing the system overall picture, abstracting from unnecessary details. This paper proposes to extend the concept of similarity of code fragments to quantify similarities at the release/system level. Similarities are captured by four software metrics representative of the commonalities and differences within and among software artifacts. To show the feasibility of characterizing large software system with the new metrics, 365 releases of the Linux kernel were analyzed. The metrics, the experimental results as well as the lessons learned are presented in the paper.},
	booktitle = {Proceedings of the 26th {Annual} {International} {Computer} {Software} and {Applications} {Conference}},
	author = {Merlo, E. and Dagenais, M. and Bachand, P. and Sormani, J. S. and Gradara, S. and Antoniol, G.},
	year = {2002},
	keywords = {clone analysis, Cloning, code fragments, Kernel, large software system, Linux, Linux kernel, Monitoring, project management, software development management, software evolution, software maintenance, software metrics, Software performance, software quality, software systems, System performance},
	pages = {421--426},
	file = {IEEE Xplore Abstract Record:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/73WSD6XV/abs_all.html:text/html;IEEE Xplore Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/SAHESC9J/Merlo et al. - 2002 - Investigating large software system evolution the.pdf:application/pdf}
}

@article{neves_investigating_2011,
	title = {Investigating the safe evolution of software product lines},
	volume = {47},
	issn = {0362-1340},
	url = {http://doi.acm.org/10.1145/2189751.2047869},
	doi = {10.1145/2189751.2047869},
	abstract = {The adoption of a product line strategy can bring significant productivity and time to market improvements. However, evolving a product line is risky because it might impact many products and their users. So when evolving a product line to introduce new features or to improve its design, it is important to make sure that the behavior of existing products is not affected. In fact, to preserve the behavior of existing products one usually has to analyze different artifacts, like feature models, configuration knowledge and the product line core assets. To better understand this process, in this paper we discover and analyze concrete product line evolution scenarios and, based on the results of this study, we describe a number of safe evolution templates that developers can use when working with product lines. For each template, we show examples of their use in existing product lines. We evaluate the templates by also analyzing the evolution history of two different product lines and demonstrating that they can express the corresponding modifications and then help to avoid the mistakes that we identified during our analysis.},
	number = {3},
	urldate = {2012-07-25},
	journal = {SIGPLAN Not.},
	author = {Neves, Laís and Teixeira, Leopoldo and Sena, Demóstenes and Alves, Vander and Kulezsa, Uirá and Borba, Paulo},
	year = {2011},
	keywords = {product line safe evolution, refinement, software product lines},
	pages = {33--42},
	file = {ACM Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/TKMUGC5X/Neves et al. - 2011 - Investigating the safe evolution of software produ.pdf:application/pdf;ACM Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/M99RCCRN/Neves et al. - 2011 - Investigating the safe evolution of software produ.pdf:application/pdf}
}

@inproceedings{sincero_is_2007,
	series = {{SPLC}-{OSSPL} '07},
	title = {Is the linux kernel a software product line},
	url = {http://fame-dbms.org/publications/SPLC-OSSPL2007-Sincero.pdf},
	urldate = {2013-02-08},
	booktitle = {Proceedings of the {International} {Workshop} on {Open} {Source} {Software} and {Product} {Lines}},
	author = {Sincero, J. and Schirmeier, H. and Schröder-Preikschat, W. and Spinczyk, O.},
	year = {2007},
	pages = {30},
	file = {SPLC-OSSPL2007-Sincero.pdf:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/WMN962K5/SPLC-OSSPL2007-Sincero.pdf:application/pdf}
}

@inproceedings{chae_language_2009,
	title = {Language support for feature-oriented product line engineering},
	isbn = {978-1-60558-567-3},
	url = {http://portal.acm.org/citation.cfm?doid=1629716.1629720},
	doi = {10.1145/1629716.1629720},
	urldate = {2016-10-25},
	publisher = {ACM Press},
	author = {Chae, Wonseok and Blume, Matthias},
	year = {2009},
	pages = {3}
}

@inproceedings{bird_latent_2008,
	address = {New York, NY, USA},
	series = {{SIGSOFT} '08/{FSE}-16},
	title = {Latent {Social} {Structure} in {Open} {Source} {Projects}},
	isbn = {978-1-59593-995-1},
	url = {http://doi.acm.org/10.1145/1453101.1453107},
	doi = {10.1145/1453101.1453107},
	abstract = {Commercial software project managers design project organizational structure carefully, mindful of available skills, division of labour, geographical boundaries, etc. These organizational "cathedrals" are to be contrasted with the "bazaar-like" nature of Open Source Software (OSS) Projects, which have no pre-designed organizational structure. Any structure that exists is dynamic, self-organizing, latent, and usually not explicitly stated. Still, in large, complex, successful, OSS projects, we do expect that subcommunities will form spontaneously within the developer teams. Studying these subcommunities, and their behavior can shed light on how successful OSS projects self-organize. This phenomenon could well hold important lessons for how commercial software teams might be organized. Building on known well-established techniques for detecting community structure in complex networks, we extract and study latent subcommunities from the email social network of several projects: Apache HTTPD, Python, PostgresSQL, Perl, and Apache ANT. We then validate them with software development activity history. Our results show that subcommunities do indeed spontaneously arise within these projects as the projects evolve. These subcommunities manifest most strongly in technical discussions, and are significantly connected with collaboration behaviour.},
	urldate = {2016-08-18},
	booktitle = {Proceedings of the 16th {ACM} {SIGSOFT} {International} {Symposium} on {Foundations} of {Software} {Engineering}},
	publisher = {ACM},
	author = {Bird, Christian and Pattison, David and D'Souza, Raissa and Filkov, Vladimir and Devanbu, Premkumar},
	year = {2008},
	keywords = {collaboration, Open source software, social networks},
	pages = {24--35},
	file = {ACM Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/948U4N4Q/Bird et al. - 2008 - Latent Social Structure in Open Source Projects.pdf:application/pdf}
}

@article{lehman_laws_1996,
	title = {Laws of software evolution revisited},
	journal = {Software process technology},
	author = {Lehman, M.},
	year = {1996},
	pages = {108--124},
	file = {Laws Of Software Evolution Revisited.pdf:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/8G65UB5N/Laws Of Software Evolution Revisited.pdf:application/pdf}
}

@article{eisenbarth_locating_2003,
	title = {Locating features in source code},
	volume = {29},
	issn = {0098-5589},
	doi = {10.1109/TSE.2003.1183929},
	abstract = {Understanding the implementation of a certain feature of a system requires identification of the computational units of the system that contribute to this feature. In many cases, the mapping of features to the source code is poorly documented. In this paper, we present a semiautomatic technique that reconstructs the mapping for features that are triggered by the user and exhibit an observable behavior. The mapping is in general not injective; that is, a computational unit may contribute to several features. Our technique allows for the distinction between general and specific computational units with respect to a given set of features. For a set of features, it also identifies jointly and distinctly required computational units. The presented technique combines dynamic and static analyses to rapidly focus on the system's parts that relate to a specific set of features. Dynamic information is gathered based on a set of scenarios invoking the features. Rather than assuming a one-to-one correspondence between features and scenarios as in earlier work, we can now handle scenarios that invoke many features. Furthermore, we show how our method allows incremental exploration of features while preserving the "mental map" the analyst has gained through the analysis.},
	number = {3},
	journal = {IEEE Transactions on Software Engineering},
	author = {Eisenbarth, T. and Koschke, R. and Simon, D.},
	month = mar,
	year = {2003},
	keywords = {feature location, formal concept analysis, identification, program analysis, program comprehension, program diagnostics, reverse engineering, Software architecture, software architecture recovery},
	pages = {210 -- 224},
	file = {IEEE Xplore Abstract Record:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/9TSPWDZR/abs_all.html:text/html;IEEE Xplore Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/C2KDACUN/Eisenbarth et al. - 2003 - Locating features in source code.pdf:application/pdf}
}

@inproceedings{rubin_managing_2013,
	address = {New York, NY, USA},
	series = {{SPLC} '13},
	title = {Managing {Cloned} {Variants}: {A} {Framework} and {Experience}},
	isbn = {978-1-4503-1968-3},
	shorttitle = {Managing {Cloned} {Variants}},
	url = {http://doi.acm.org/10.1145/2491627.2491644},
	doi = {10.1145/2491627.2491644},
	abstract = {In our earlier work, we have proposed a generic framework for managing collections of related products realized via cloning -- both in the case when such products are refactored into a single-copy software product line representation and the case when they are maintained as distinct clones. In this paper, we ground the framework in empirical evidence and exemplify its usefulness. In particular, we systematically analyze three industrial case studies of organizations with cloned product lines and derive the set of basic operators comprising the framework. We discuss options for implementing the operators and benefits of the operator-based view.},
	urldate = {2016-07-04},
	booktitle = {Proceedings of the 17th {International} {Software} {Product} {Line} {Conference}},
	publisher = {ACM},
	author = {Rubin, Julia and Czarnecki, Krzysztof and Chechik, Marsha},
	year = {2013},
	keywords = {cloned product variants, industrial case studies, legacy software product lines},
	pages = {101--110},
	file = {ACM Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/Q5DI62VU/Rubin et al. - 2013 - Managing Cloned Variants A Framework and Experien.pdf:application/pdf}
}

@inproceedings{holl_managing_2012,
	series = {{VaMoS} '12},
	title = {Managing {Emerging} {Configuration} {Dependencies} in {Multi} {Product} {Lines}},
	isbn = {978-1-4503-1058-1},
	doi = {10.1145/2110147.2110148},
	abstract = {Large-scale software-intensive systems often consist of multiple heterogeneous and loosely coupled systems, which work together to form a system of systems (SoS). The individual systems often represent configurable units that need be adapted to customer requirements. In such multi product line environments, configuration dependencies between the product lines need to be discovered and enforced. Based on an analysis of the SoSs of our industry partners in the domains of medical systems and industrial automation, we identify several types of configuration dependencies between product lines. In particular, we point out the importance of emerging dependencies, which are not known in advance, but are detected in the course of the configuration process. For handling such emerging dependencies, we developed tool extensions to the DOPLER tool suite that provide support for the distributed configuration of multi product lines by multiple users and that support the inference of dependencies from emerging dependencies by observing user actions. We conducted a preliminary evaluation to assess our tool-supported approach. Our extensible set of dependency types turned out to be suitable for modeling configuration dependencies between product lines in the study system. The evaluation further showed the usefulness of the tool for capturing emerging dependencies by multiple users during distributed configuration.},
	urldate = {2014-02-17},
	booktitle = {Proc. of the 6th {International} {Workshop} on {Variability} {Modeling} of {Software}-{Intensive} {Systems}},
	publisher = {ACM},
	author = {Holl, Gerald and Thaller, Daniel and Grünbacher, Paul and Elsner, Christoph},
	year = {2012},
	keywords = {configuration dependencies, multi product lines, systems-of-systems, Tool support},
	pages = {3--10},
	file = {ACM Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/F7MCX23D/Holl et al. - 2012 - Managing Emerging Configuration Dependencies in Mu.pdf:application/pdf}
}

@techreport{acher_managing_2010,
	type = {Research report},
	title = {Managing multiple software product lines using merging techniques},
	abstract = {Managing multiple software product lines using merging techniques},
	number = {ISRN I3S/RR–20 10 - 06 –FR},
	urldate = {2014-03-04},
	institution = {Laboratoire d’Informatique de Signaux et Systèmes de Sophia Antipolis - UNSA-CNRS},
	author = {Acher, Mathieu and Collet, Philippe and Lahire, Philippe and France, Robert},
	year = {2010},
	keywords = {academia, academics, Biology, Chemistry, Computer Science, Earth Sciences, Economics, English, Geography, History, Law, Math, Medicine, Philosophy, Physics, Political Science, Psychology, Religion, research, universities},
	file = {Snapshot:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/5K47GIFP/Managing_multiple_software_product_lines_using_merging_techniques.html:text/html}
}

@article{babar_managing_2010,
	title = {Managing {Variability} in {Software} {Product} {Lines}},
	volume = {27},
	issn = {0740-7459},
	url = {http://ieeexplore.ieee.org/document/5452151/},
	doi = {10.1109/MS.2010.77},
	number = {3},
	urldate = {2016-12-05},
	journal = {IEEE Software},
	author = {Babar, Muhammad Ali and {Lianping Chen} and Shull, Forrest},
	month = may,
	year = {2010},
	pages = {89--91, 94}
}

@inproceedings{acher_managing_2010-1,
	series = {{SC} '10},
	title = {Managing {Variability} in {Workflow} with {Feature} {Model} {Composition} {Operators}},
	copyright = {©2010 Springer-Verlag Berlin Heidelberg},
	isbn = {978-3-642-14045-7 978-3-642-14046-4},
	abstract = {In grid-based scientific applications, building a workflow essentially involves composing parameterized services describing families of services and then configuring the resulting workflow product line. In domains (e.g., medical imaging) in which many different kinds of highly parameterized services exist, there is a strong need to manage variabilities so that scientists can more easily configure and compose services with consistency guarantees. In this paper, we propose an approach in which variable points in services are described with several separate feature models, so that families of workflow can be defined as compositions of feature models. A compositional technique then allows reasoning about the compatibility between connected services to ensure consistency of an entire workflow, while supporting automatic propagation of variability choices when configuring services.},
	urldate = {2014-02-17},
	booktitle = {Proc. of the 9th {International} {Conf}. on {Software} {Composition}},
	publisher = {Springer Berlin Heidelberg},
	author = {Acher, Mathieu and Collet, Philippe and Lahire, Philippe and France, Robert},
	editor = {Baudry, Benoît and Wohlstadter, Eric},
	month = jul,
	year = {2010},
	keywords = {Computer Communication Networks, Logics and Meanings of Programs, Programming Languages, Compilers, Interpreters, Programming Techniques, software engineering, Software Engineering/Programming and Operating Systems},
	pages = {17--33},
	file = {Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/D635Q2TC/Acher et al. - 2010 - Managing Variability in Workflow with Feature Mode.pdf:application/pdf;Snapshot:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/D62MFGH5/10.html:text/html}
}

@incollection{czarnecki_mapping_2005,
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Mapping {Features} to {Models}: {A} {Template} {Approach} {Based} on {Superimposed} {Variants}},
	volume = {3676},
	isbn = {978-3-540-29138-1},
	shorttitle = {Mapping {Features} to {Models}},
	url = {http://www.springerlink.com/content/9n4uhh2gaddj5lkv/abstract/},
	abstract = {Although a feature model can represent commonalities and variabilities in a very concise taxonomic form, features in a feature model are merely symbols. Mapping features to other models, such as behavioral or data specifications, gives them semantics. In this paper, we propose a general template-based approach for mapping feature models to concise representations of variability in different kinds of other models. We show how the approach can be applied to UML 2.0 activity and class models and describe a prototype implementation.},
	urldate = {2012-10-23},
	booktitle = {Generative {Programming} and {Component} {Engineering}},
	publisher = {Springer Berlin / Heidelberg},
	author = {Czarnecki, Krzysztof and Antkiewicz, Michał},
	editor = {Glück, Robert and Lowry, Michael},
	year = {2005},
	keywords = {Computer Science},
	pages = {422--437},
	file = {SpringerLink Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/CE7TAEI9/Czarnecki and Antkiewicz - 2005 - Mapping Features to Models A Template Approach Ba.pdf:application/pdf;SpringerLink Snapshot:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/DDJAENPK/abstract.html:text/html}
}

@inproceedings{mcilroy_mass-produced_1968,
	series = {{ICSE}'68},
	title = {Mass-produced software components},
	booktitle = {Proceedings of the 1st {International} {Conference} on {Software} {Engineering}},
	author = {McIlroy, M and Douglas, J and Buxton, J and Naur, P and Randell, B},
	year = {1968}
}

@incollection{kolovos_migrating_2015,
	address = {Cham},
	title = {Migrating {Automotive} {Product} {Lines}: {A} {Case} {Study}},
	volume = {9152},
	isbn = {978-3-319-21154-1 978-3-319-21155-8},
	shorttitle = {Migrating {Automotive} {Product} {Lines}},
	url = {http://link.springer.com/10.1007/978-3-319-21155-8_7},
	urldate = {2016-10-27},
	booktitle = {Theory and {Practice} of {Model} {Transformations}},
	publisher = {Springer International Publishing},
	author = {Famelis, Michalis and Lúcio, Levi and Selim, Gehan and Di Sandro, Alessio and Salay, Rick and Chechik, Marsha and Cordy, James R. and Dingel, Juergen and Vangheluwe, Hans and S., Ramesh},
	editor = {Kolovos, Dimitris and Wimmer, Manuel},
	year = {2015},
	pages = {82--97}
}

@inproceedings{nadi_mining_2014,
	series = {{ICSE} '14},
	title = {Mining configuration constraints: static analyses and empirical results},
	isbn = {978-1-4503-2756-5},
	shorttitle = {Mining configuration constraints},
	url = {http://dl.acm.org/citation.cfm?doid=2568225.2568283},
	doi = {10.1145/2568225.2568283},
	urldate = {2015-07-06},
	booktitle = {Proceedings of the 36th {International} {Conference} on {Software} {Engineering}},
	publisher = {ACM Press},
	author = {Nadi, Sarah and Berger, Thorsten and Kästner, Christian and Czarnecki, Krzysztof},
	year = {2014},
	pages = {140--151}
}

@misc{nadi_mining_2014-1,
	title = {Mining {Configuration} {Constraints}: {Static} {Analyses} and {Empirical} {Results}},
	shorttitle = {Mining {Configuration} {Constraints}},
	author = {Nadi, Sarah},
	year = {2014},
	file = {Mining Configuration Constraints\: Static Analyses and Empirical Results | Generative Software Development Lab:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/DR5WHNXZ/554.html:text/html}
}

@inproceedings{li_mining_2016,
	title = {Mining families of android applications for extractive {SPL} adoption},
	isbn = {978-1-4503-4050-2},
	url = {http://dl.acm.org/citation.cfm?doid=2934466.2946047},
	doi = {10.1145/2934466.2946047},
	urldate = {2016-11-15},
	publisher = {ACM Press},
	author = {Li, Li and Martinez, Jabier and Ziadi, Tewfik and Bissyandé, Tegawendé F. and Klein, Jacques and Traon, Yves Le},
	year = {2016},
	pages = {271--275}
}

@inproceedings{nadi_mining_2012,
	series = {{CSMR} '12},
	title = {Mining {Kbuild} to {Detect} {Variability} {Anomalies} in {Linux}},
	doi = {10.1109/CSMR.2012.21},
	abstract = {The Linux kernel is extensively specialized or configured so that it can be used for many purposes. This variability is implemented by means of three distinct artifacts: source code files, Kconfig (configuration) files, and Make files. Any inconsistencies between these three can lead to undesirable anomalies which can lead to increased maintenance efforts or decreased reliability. This paper extends published work that had found anomalies (dead and undead code blocks) by concentrating largely on code and Kconfig files. We detect further anomalies in the Linux kernel when we also consider the Make files. At the level of code blocks, our work exposes many additional anomalies - more than we could study manually. We found that when we lift the level from code blocks to code files, the detected anomalies became easier to study and understand and thus more useful to the developer. By means of examples, we illustrate how the anomalies we detect can lead to undesired behavior. We show how, over time, developers tend to find and delete such anomalies. We suggest that automatic detection of such anomalies has the potential to decrease maintenance efforts and increase reliability.},
	booktitle = {Proceedings of the 16th {European} {Conference} on {Software} {Maintenance} and {Reengineering}},
	author = {Nadi, S. and Holt, R.},
	year = {2012},
	keywords = {Buildings, build systems, data flow analysis, data mining, feature extraction, kbuild, Kbuild mining, Kernel, Linux, Linux kernel, Maintenance engineering, mining software repositories, operating system kernels, Reliability, security of data, software maintenance, Universal Serial Bus, variability, variability anomaly detection},
	pages = {107--116},
	file = {IEEE Xplore Abstract Record:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/VVD44CN2/abs_all.html:text/html}
}

@inproceedings{zimmermann_mining_2004,
	series = {{ICSE} '04},
	title = {Mining version histories to guide software changes},
	doi = {10.1109/ICSE.2004.1317478},
	abstract = {We apply data mining to version histories in order to guide programmers along related changes: "Programmers who changed these functions also changed. . . ". Given a set of existing changes, such rules (a) suggest and predict likely further changes, (b) show up item coupling that is indetectable by program analysis, and (c) prevent errors due to incomplete changes. After an initial change, our ROSE prototype can correctly predict 26\% of further files to be changed - and 15\% of the precise functions or variables. The topmost three suggestions contain a correct location with a likelihood of 64\%.},
	booktitle = {Proceedings of the 26th {International} {Conference} on {Software} {Engineering}},
	author = {Zimmermann, T. and Weibgerber, P. and Diehl, S. and Zeller, A.},
	month = may,
	year = {2004},
	keywords = {configuration management, data mining, program analysis, program diagnostics, ROSE, software changes, software maintenance, software management, version histories},
	pages = {563 -- 572},
	file = {IEEE Xplore Abstract Record:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/XIFMZK9H/cookiedetectresponse.html:text/html;IEEE Xplore Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/JPTG4V84/Zimmermann et al. - 2004 - Mining version histories to guide software changes.pdf:application/pdf}
}

@article{pleuss_model-driven_2012,
	title = {Model-driven support for product line evolution on feature level},
	volume = {85},
	issn = {01641212},
	url = {http://linkinghub.elsevier.com/retrieve/pii/S0164121211002093},
	doi = {10.1016/j.jss.2011.08.008},
	number = {10},
	urldate = {2013-08-27},
	journal = {Journal of Systems and Software},
	author = {Pleuss, Andreas and Botterweck, Goetz and Dhungana, Deepak and Polzer, Andreas and Kowalewski, Stefan},
	month = oct,
	year = {2012},
	pages = {2261--2274},
	file = {Pleuss et al - Model-driven support for SPL evolution -2012.pdf:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/B638588C/Pleuss et al - Model-driven support for SPL evolution -2012.pdf:application/pdf}
}

@inproceedings{jaring_modeling_2008,
	series = {{ICCBSS} '08},
	title = {Modeling {Variability} and {Testability} {Interaction} in {Software} {Product} {Line} {Engineering}},
	doi = {10.1109/ICCBSS.2008.9},
	abstract = {Software product line engineering is often a more laborious process than anticipated beforehand, not in the least due to a growing demand for product features and an ever increasing complexity of the dependencies between functional components. One of the main ideas in software product line engineering is to delay variant binding, i.e., to delay the composition of particular product features to a later moment in the development or deployment process. Delaying variant binding affects testability, e.g., a full integration test is not possible before all the appropriate product variants have been bound. This paper suggests a variability and testability interaction model (VTIM) to better anticipate the software product line testing process. VTIM is applied in a case study in expressing the relationship between variability and testability for several variation points in a large-scale software product line of magnetic resonance imaging scanners developed by Philips Medical Systems. The case study illustrates how VTIM can be used as an analysis tool in everyday software engineering practice.},
	booktitle = {Proc. of the 7th {International} {Conference} on {Composition}-{Based} {Software} {Systems}},
	author = {Jaring, M. and Krikhaar, R.L. and Bosch, J.},
	year = {2008},
	keywords = {Biomedical imaging, biomedical MRI, computer architecture, Delay, delay variant binding, large-scale software product line, Magnetic resonance imaging, magnetic resonance imaging scanners, Medical tests, Philips Medical Systems, program testing, software engineering, software maintenance, software product line, software product line testing process, software systems, Software testing, System testing, testability, variability, variability and testability interaction model, variability-testability interaction},
	pages = {120--129},
	file = {IEEE Xplore Abstract Record:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/HCRSCQNP/articleDetails.html:text/html;IEEE Xplore Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/F3RT82EZ/Jaring et al. - 2008 - Modeling Variability and Testability Interaction i.pdf:application/pdf}
}

@article{reiser_multi-level_2007,
	title = {Multi-level {Feature} {Trees}: {A} {Pragmatic} {Approach} to {Managing} {Highly} {Complex} {Product} {Families}},
	volume = {12},
	issn = {0947-3602},
	shorttitle = {Multi-level {Feature} {Trees}},
	doi = {10.1007/s00766-007-0046-0},
	abstract = {Feature modeling has become a popular technique for domain analysis and variability management. However, it is still a considerable challenge to apply this technique to product families and organizational contexts of high complexity like the product range of a global automotive corporation. Managing everything as a single product family with a global feature tree is virtually impossible owing to the enormous complexity, but if the product range is split up into several smaller, independent product lines with separate feature models, systematic reuse and strategic variability management across these portions is lost. In this article, we present multi-level feature trees, which offer a compromise between a single global and several smaller, independent feature trees. Other development artifacts may also be arranged in this way if the multi-level concept is adapted to them. This is shown exemplarily for requirements artifacts in Telelogic Doors. Finally, we describe scenarios showing how this concept can be put into practice.},
	number = {2},
	urldate = {2014-03-04},
	journal = {Requirements Engineering},
	author = {Reiser, Mark-Oliver and Weber, Matthias},
	month = may,
	year = {2007},
	keywords = {Automotive software, domain analysis, Requirements engineering, software product lines},
	pages = {57--75}
}

@inproceedings{krueger_new_2006,
	series = {{SPLC} '06},
	title = {New methods in software product line development},
	doi = {10.1109/SPLINE.2006.1691581},
	abstract = {A new generation of software product line success stories is being driven by a new generation of methods, tools and techniques. While early software product line case studies at the genesis of the field revealed some of the best software engineering improvement metrics seen in four decades, the latest generation of software product line success stories exhibit even greater improvements, extending benefits beyond product creation into maintenance and evolution, lowering the overall complexity of product line development, increasing the scalability of product line portfolios, and enabling organizations to make the transition to software product line practice with orders of magnitude less time, cost and effort. This paper describes some of the best methods from the industry's most recent software product line successes},
	booktitle = {Proc. of the 10th {International} {Software} {Product} {Line} {Conference}},
	publisher = {IEEE Computer Society},
	author = {Krueger, C.W.},
	month = aug,
	year = {2006},
	keywords = {Application software, Computer industry, Logic, Manufacturing automation, Mass customization, product development, product line portfolios, Programming, software development management, software engineering, software evolution, software maintenance, software product line development, software reusability, software tools},
	pages = {95--99},
	file = {IEEE Xplore Abstract Record:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/AAFQ3U2U/cookiedetectresponse.html:text/html;IEEE Xplore Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/KURH5MAB/Krueger - 2006 - New methods in software product line development.pdf:application/pdf}
}

@inproceedings{guo_not_2011,
	title = {"{Not} my bug!" and other reasons for software bug report reassignments},
	isbn = {978-1-4503-0556-3},
	url = {http://portal.acm.org/citation.cfm?doid=1958824.1958887},
	doi = {10.1145/1958824.1958887},
	language = {en},
	urldate = {2017-06-22},
	publisher = {ACM Press},
	author = {Guo, Philip J. and Zimmermann, Thomas and Nagappan, Nachiappan and Murphy, Brendan},
	year = {2011},
	pages = {395}
}

@incollection{treiber_analyzing_2009,
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {On {Analyzing} {Evolutionary} {Changes} of {Web} {Services}},
	copyright = {©2009 Springer Berlin Heidelberg},
	isbn = {978-3-642-01246-4 978-3-642-01247-1},
	url = {http://link.springer.com/chapter/10.1007/978-3-642-01247-1_29},
	abstract = {Web services evolve over their life time and change their behavior. In our work, we analyze Web service related changes and investigate interdependencies of Web service related changes. We classify changes of Web services for an analysis regarding causes and effects of such changes and utilize a dedicated Web service information model to capture the changes of Web services. We show how to put changes of Web services into an evolutionary context that allows us to develop a holistic perspective on Web services and their stakeholders in a ecosystem of Web services.},
	number = {5472},
	urldate = {2013-10-03},
	booktitle = {Service-{Oriented} {Computing} – {ICSOC} 2008 {Workshops}},
	publisher = {Springer Berlin Heidelberg},
	author = {Treiber, Martin and Truong, Hong-Linh and Dustdar, Schahram},
	editor = {Feuerlicht, George and Lamersdorf, Winfried},
	month = jan,
	year = {2009},
	keywords = {Business Information Systems, Computer Communication Networks, Computers and Society, Information Storage and Retrieval, Information Systems Applications (incl.Internet), software engineering},
	pages = {284--297},
	file = {Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/6WAIU6RX/Treiber et al. - 2009 - On Analyzing Evolutionary Changes of Web Services.pdf:application/pdf;Snapshot:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/4D92NA7M/978-3-642-01247-1_29.html:text/html}
}

@inproceedings{storey_designing_1996,
	series = {{WCRE} '96},
	title = {On designing an experiment to evaluate a reverse engineering tool},
	doi = {10.1109/WCRE.1996.558826},
	abstract = {The Rigi reverse engineering system is designed to analyze and summarize the structure of large software systems. Two contrasting approaches are available for visualizing software structures in the Rigi graph editor. The first approach displays the structures through multiple, individual windows. The second approach, simple hierarchical multi-perspective (SHriMP) views, employs fisheye views of nested graphs. The paper describes the design of an experiment to evaluate these alternative user interfaces. Various results from a preliminary pilot study to test the experiment design are reported},
	booktitle = {Proceedings of the {Third} {Working} {Conference} on {Reverse} {Engineering}},
	author = {Storey, M.-A.D. and Wong, K. and Fong, P. and Hooper, D. and Hopkins, K. and Muller, H.A.},
	month = nov,
	year = {1996},
	keywords = {Computer displays, Computer Science, fisheye views, large software systems, multiple individual windows, Navigation, nested graphs, reverse engineering, reverse engineering tool evaluation experiment design, Rigi graph editor, Rigi reverse engineering system, simple hierarchical multi-perspective views, software design, software maintenance, software structure visualization, software systems, Software testing, software tools, System testing, user interfaces, WINDOWS},
	pages = {31--40},
	file = {IEEE Xplore Abstract Record:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/PZQMB4TU/abs_all.html:text/html;IEEE Xplore Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/8D99MNH9/Storey et al. - 1996 - On designing an experiment to evaluate a reverse e.pdf:application/pdf}
}

@inproceedings{antoniol_feature_2005,
	address = {New York, NY, USA},
	series = {{TEFSE} '05},
	title = {On {Feature} {Traceability} in {Object} {Oriented} {Programs}},
	isbn = {1-59593-243-7},
	url = {http://doi.acm.org/10.1145/1107656.1107672},
	doi = {10.1145/1107656.1107672},
	abstract = {Open-source and industrial software systems often lack up-to-date documents on the implementation of user-observable functionalities. This lack of documents is particularly hindering for large systems. Moreover, as with any other software artifacts, user-observable functionalities evolve through software evolution activities. Evolution activities sometimes have undesired and unexpected side-effects on other functionalities, causing these to fail or to malfunction. In this position paper, we promote the idea that a traceability link between user-observable functionalities and constituents of a software architecture (classes, methods. . . implementing the functionalities) is essential to reduce the software evolution effort. We outline an approach to recover and to study the evolution of features---subsets of the constituents of a software architecture---responsible for a functionality.},
	urldate = {2014-10-24},
	booktitle = {Proceedings of the 3rd {International} {Workshop} on {Traceability} in {Emerging} {Forms} of {Software} {Engineering}},
	publisher = {ACM},
	author = {Antoniol, Giuliano and Merlo, Ettore and Guéhéneuc, Yann-Gaël and Sahraoui, Houari},
	year = {2005},
	keywords = {during, evolution, feature, traceability},
	pages = {73--78},
	file = {ACM Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/H7FE9EW7/Antoniol et al. - 2005 - On Feature Traceability in Object Oriented Program.pdf:application/pdf}
}

@article{parnas_design_1976,
	title = {On the {Design} and {Development} of {Program} {Families}},
	volume = {SE-2},
	issn = {0098-5589},
	doi = {10.1109/TSE.1976.233797},
	abstract = {Program families are defined (analogously to hardware families) as sets of programs whose common properties are so extensive that it is advantageous to study the common properties of the programs before analyzing individual members. The assumption that, if one is to develop a set of similar programs over a period of time, one should consider the set as a whole while developing the first three approaches to the development, is discussed. A conventional approach called "sequential development" is compared to "stepwise refinement" and "specification of information hiding modules." A more detailed comparison of the two methods is then made. By means of several examples it is demonstrated that the two methods are based on the same concepts but bring complementary advantages.},
	number = {1},
	journal = {IEEE Transactions on Software Engineering},
	author = {Parnas, D.L.},
	month = mar,
	year = {1976},
	keywords = {Algorithm design and analysis, Costs, hardware, Information hiding modules, Manufacturing, module specifications, Operating Systems, Production, program families, Programming profession, software design, software design methodology, software engineering, software maintenance, stepwise refimement},
	pages = {1--9},
	file = {IEEE Xplore Abstract Record:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/63AIXEKG/abs_all.html:text/html;IEEE Xplore Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/MDV834SC/Parnas - 1976 - On the Design and Development of Program Families.pdf:application/pdf}
}

@inproceedings{kastner_impact_2009,
	address = {Pittsburgh, PA, USA},
	series = {{SPLC} '09},
	title = {On the impact of the optional feature problem: analysis and case studies},
	shorttitle = {On the impact of the optional feature problem},
	url = {http://dl.acm.org/citation.cfm?id=1753235.1753261},
	abstract = {A software product line is a family of related programs that are distinguished in terms of features. A feature implements a stakeholders' requirement. Different program variants specified by distinct feature selections are produced from a common code base. The optional feature problem describes a common mismatch between variability intended in the domain and dependencies in the implementation. When this situation occurs, some variants that are valid in the domain cannot be produced due to implementation issues. There are many different solutions to the optional feature problem, but they all suffer from drawbacks such as reduced variability, increased development effort, reduced efficiency, or reduced source code quality. We examine the impact of the optional feature problem in two case studies from the domain of embedded database systems, and we survey different state-of-the-art solutions and their trade-offs. Our intension is to raise awareness of the problem, to guide developers in selecting an appropriate solution for their product line, and to identify opportunities for future research.},
	urldate = {2012-07-31},
	booktitle = {Proceedings of the 13th {International} {Software} {Product} {Line} {Conference}},
	publisher = {Carnegie Mellon University},
	author = {Kästner, Christian and Apel, Sven and ur Rahman, Syed Saif and Rosenmüller, Marko and Batory, Don and Saake, Gunter},
	year = {2009},
	pages = {181--190},
	file = {ACM Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/CTJKGNEI/Kästner et al. - 2009 - On the impact of the optional feature problem ana.pdf:application/pdf}
}

@inproceedings{van_gurp_notion_2001,
	series = {{WICSA} '01},
	title = {On the notion of variability in software product lines},
	doi = {10.1109/WICSA.2001.948406},
	abstract = {The authors discuss the notion of variability. We have experienced that this concept has so far been underdefined, although we have observed that variability techniques become increasingly important. A clear indication of this trend is the recent emergence of software product lines. Software product lines are large, industrial software systems intended to specialize into specific software products. The authors provide a framework of terminology and concepts regarding variability. In addition, they present three recurring patterns of variability. Finally, they suggest a method for managing variability in software product lines},
	booktitle = {Proceedings of the {Working} {IEEE}/{IFIP} {Conference} on {Software} {Architecture}},
	author = {van Gurp, J. and Bosch, J. and Svahnberg, M.},
	year = {2001},
	keywords = {DP industry, large industrial software systems, recurring variability patterns, software development management, software packages, software product line variability, terminology, variability techniques},
	pages = {45 --54},
	file = {Citeseer - Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/DW9GQKK9/Gurp et al. - 2001 - On the Notion of Variability in Software Product L.pdf:application/pdf;Citeseer - Snapshot:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/I9W2CS8R/summary.html:text/html;IEEE Xplore Abstract Record:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/T8WPGJE8/stamp.html:text/html;IEEE Xplore Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/QHBF7NT2/van Gurp et al. - 2001 - On the notion of variability in software product l.pdf:application/pdf}
}

@inproceedings{van_gurp_notion_2001-1,
	series = {{WICSA} '01},
	title = {On the notion of variability in software product lines},
	isbn = {978-0-7695-1360-7},
	url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=948406},
	doi = {10.1109/WICSA.2001.948406},
	urldate = {2016-01-10},
	booktitle = {Proceedings of the {Working} {IEEE}/{IFIP} {Conference} on {Software} {Architecture}},
	publisher = {IEEE Comput. Soc},
	author = {van Gurp, J. and Bosch, J. and Svahnberg, M.},
	year = {2001},
	pages = {45--54}
}

@inproceedings{jaafar_relationship_2013,
	series = {{CSMR}'13},
	title = {On the {Relationship} between {Program} {Evolution} and {Fault}-{Proneness}: {An} {Empirical} {Study}},
	doi = {10.1109/CSMR.2013.12},
	booktitle = {17th {European} {Conference} on {Software} {Maintenance} and {Reengineering}},
	author = {Jaafar, F. and Hassaine, S. and Gueheneuc, Y. and Hamel, S. and Adams, B.},
	month = mar,
	year = {2013},
	keywords = {ArgoUML, Bit vectors, Co-evolution, coevolution trends, Evolutionary history, Fault-proneness, JFreechart, lifetime models, object-oriented programming, object-oriented source code evolution, object-oriented source code maintenance, open-source programs, phylogenetic trees, program code decay, program evolution, program evolutionary history, program fault-proneness, public domain software, Reverse engineering, software fault tolerance, software maintenance, Unified Modeling Language, XercesJ},
	pages = {15--24}
}

@inproceedings{sampaio_partially_2016,
	title = {Partially {Safe} {Evolution} of {Software} {Product} {Lines}},
	booktitle = {Proceedings of the 20th {International} {Systems} and {Software} {Product} {Line} {Conference} (to appear)},
	publisher = {ACM},
	author = {Sampaio, Gabriela and Borba, Paulo and Teixeira, Leopoldo},
	year = {2016}
}

@inproceedings{juanjuan_jiang_pattern-based_2005,
	title = {Pattern-based variability management in {Web} service development},
	isbn = {978-0-7695-2484-9},
	url = {http://ieeexplore.ieee.org/document/1595719/},
	doi = {10.1109/ECOWS.2005.19},
	urldate = {2016-10-27},
	publisher = {IEEE},
	author = {{Juanjuan Jiang} and Ruokonen, A. and Systa, T.},
	year = {2005},
	pages = {12 pp.}
}

@incollection{goos_pattern_2001,
	address = {Berlin, Heidelberg},
	title = {Pattern {Structures} and {Their} {Projections}},
	volume = {2120},
	isbn = {978-3-540-42344-7 978-3-540-44583-8},
	url = {http://link.springer.com/10.1007/3-540-44583-8_10},
	urldate = {2015-07-21},
	booktitle = {Conceptual {Structures}: {Broadening} the {Base}},
	publisher = {Springer Berlin Heidelberg},
	author = {Ganter, Bernhard and Kuznetsov, Sergei O.},
	editor = {Goos, G. and Hartmanis, J. and van Leeuwen, J. and Delugach, Harry S. and Stumme, Gerd},
	year = {2001},
	pages = {129--142}
}

@article{sturges_polypsychopharmacy_1975,
	title = {Polypsychopharmacy},
	volume = {39},
	issn = {0025-9284},
	language = {ENG},
	number = {3},
	journal = {Bulletin of the Menninger Clinic},
	author = {Sturges, S. and Brown, M.},
	month = may,
	year = {1975},
	pmid = {110},
	keywords = {Antiparkinson Agents, Antipsychotic Agents, Drug Therapy, Combination, Humans, Mental Disorders, Patient Compliance, Psychiatric Department, Hospital, Psychopharmacology},
	pages = {274--279}
}

@article{louridas_power_2008,
	title = {Power laws in software},
	volume = {18},
	issn = {1049331X},
	url = {http://portal.acm.org/citation.cfm?doid=1391984.1391986},
	doi = {10.1145/1391984.1391986},
	number = {1},
	urldate = {2015-07-30},
	journal = {ACM Transactions on Software Engineering and Methodology},
	author = {Louridas, Panagiotis and Spinellis, Diomidis and Vlachos, Vasileios},
	month = sep,
	year = {2008},
	pages = {1--26}
}

@article{ying_predicting_2004,
	title = {Predicting {Source} {Code} {Changes} by {Mining} {Change} {History}},
	volume = {30},
	issn = {0098-5589},
	url = {http://dx.doi.org/10.1109/TSE.2004.52},
	doi = {10.1109/TSE.2004.52},
	abstract = {Software developers are often faced with modification tasks that involve source which is spread across a code base. Some dependencies between source code, such as those between source code written in different languages, are difficult to determine using existing static and dynamic analyses. To augment existing analyses and to help developers identify relevant source code during a modification task, we have developed an approach that applies data mining techniques to determine change patterns¿sets of files that were changed together frequently in the past¿from the change history of the code base. Our hypothesis is that the change patterns can be used to recommend potentially relevant source code to a developer performing a modification task. We show that this approach can reveal valuable dependencies by applying the approach to the Eclipse and Mozilla open source projects and by evaluating the predictability and interestingness of the recommendations produced for actual modification tasks on these systems.},
	number = {9},
	urldate = {2014-10-07},
	journal = {IEEE Trans. Softw. Eng.},
	author = {Ying, Annie T. T. and Murphy, Gail C. and Ng, Raymond and Chu-Carroll, Mark C.},
	month = sep,
	year = {2004},
	keywords = {65, association rules, classification, clustering, data mining., Index Terms- Enhancement, maintainability},
	pages = {574--586},
	file = {Ying - Predicting Source Code Changes by Mining Change History - 2004.pdf:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/FKPUNIEJ/Ying - Predicting Source Code Changes by Mining Change History - 2004.pdf:application/pdf}
}

@article{ying_predicting_2004-1,
	title = {Predicting source code changes by mining change history},
	volume = {30},
	issn = {0098-5589},
	url = {http://trese.cs.utwente.nl/publications/files/04692004-tse-mine-change.pdf},
	doi = {10.1109/TSE.2004.52},
	number = {9},
	journal = {IEEE Transactions on Software Engineering},
	author = {Ying, A.T.T. and Murphy, G.C. and Ng, R. and Chu-Carroll, M.C.},
	month = sep,
	year = {2004},
	pages = {574--586}
}

@article{hunsen_preprocessor-based_2015,
	title = {Preprocessor-based variability in open-source and industrial software systems: {An} empirical study},
	issn = {1382-3256, 1573-7616},
	shorttitle = {Preprocessor-based variability in open-source and industrial software systems},
	url = {http://link.springer.com/10.1007/s10664-015-9360-1},
	doi = {10.1007/s10664-015-9360-1},
	urldate = {2016-01-20},
	journal = {Empirical Software Engineering},
	author = {Hunsen, Claus and Zhang, Bo and Siegmund, Janet and Kästner, Christian and Leßenich, Olaf and Becker, Martin and Apel, Sven},
	month = apr,
	year = {2015}
}

@inproceedings{thuem_reasoning_2009,
	series = {{ICSE} '09},
	title = {Reasoning about edits to feature models},
	urldate = {2012-09-11},
	booktitle = {Proc. of the 31st {International} {Conference} on {Software} {Engineering}},
	publisher = {IEEE Computer Society},
	author = {Thuem, T. and Batory, D. and Kaestner, C.},
	year = {2009},
	pages = {254--264},
	file = {Reasoning about Edits to Feature Models.pdf:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/4FAVT3CG/Reasoning about Edits to Feature Models.pdf:application/pdf}
}

@inproceedings{alves_refactoring_2006,
	series = {{GPCE} '06},
	title = {Refactoring product lines},
	isbn = {1-59593-237-2},
	url = {http://doi.acm.org/10.1145/1173706.1173737},
	doi = {10.1145/1173706.1173737},
	abstract = {Adoption strategies for Software Product Lines (SPL) frequently involve bootstrapping existing products into a SPL and extending an existing SPL to encompass another product. One way to do that is to use program refactorings. However, the traditional notion of refactoring does not handle appropriately feature models (FM), nor transformations involving multiple instances of the same SPL. For instance, it is not desirable to apply a refactoring into a SPL and reduce its configurability. In this paper, we extend the traditional notion of refactoring to an SPL context. Besides refactoring programs, FMs must also be refactored. We present a set of sound refactorings for FMs. We evaluate this extended refactoring definition for SPL in a real case study in the mobile games domain.},
	urldate = {2013-10-08},
	booktitle = {Proceedings of the 5th international conference on {Generative} programming and component engineering},
	publisher = {ACM},
	author = {Alves, Vander and Gheyi, Rohit and Massoni, Tiago and Kulesza, Uirá and Borba, Paulo and Lucena, Carlos},
	year = {2006},
	keywords = {feature model, refactoring, software product lines},
	pages = {201--210},
	file = {ACM Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/GDM4TDZ8/Alves et al. - 2006 - Refactoring product lines.pdf:application/pdf}
}

@incollection{heidenreich_relating_2010,
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Relating {Feature} {Models} to {Other} {Models} of a {Software} {Product} {Line}},
	copyright = {©2010 Springer-Verlag Berlin Heidelberg},
	isbn = {978-3-642-16085-1 978-3-642-16086-8},
	url = {http://link.springer.com/chapter/10.1007/978-3-642-16086-8_3},
	abstract = {Software product lines using feature models often require the relation between feature models in problem space and the models used to describe the details of the product line to be expressed explicitly. This is particularly important, where automatic product derivation is required. Different approaches for modelling this mapping have been proposed in the literature. However, a discussion of their relative benefits and drawbacks is currently missing. As a first step towards a better understanding of this field, this paper applies two of these approaches—FeatureMapper as a representative of declarative approaches and VML* as a representative of operational approaches—to the case study. We show in detail how the case study can be expressed using these approaches and discuss strengths and weaknesses of the two approaches with regard to the case study.},
	number = {6210},
	urldate = {2012-11-26},
	booktitle = {Transactions on {Aspect}-{Oriented} {Software} {Development} {VII}},
	publisher = {Springer Berlin Heidelberg},
	author = {Heidenreich, Florian and Sánchez, Pablo and Santos, João and Zschaler, Steffen and Alférez, Mauricio and Araújo, João and Fuentes, Lidia and Kulesza, Uirá and Moreira, Ana and Rashid, Awais},
	editor = {Katz, Shmuel and Mezini, Mira and Kienzle, Jörg},
	year = {2010},
	keywords = {Computer Communication Networks, Logics and Meanings of Programs, Management of Computing and Information Systems, Programming Languages, Compilers, Interpreters, Programming Techniques, software engineering},
	pages = {69--114},
	file = {Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/6MJSPM6S/Heidenreich et al. - 2010 - Relating Feature Models to Other Models of a Softw.pdf:application/pdf;Snapshot:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/2U5BGTIP/10.html:text/html}
}

@incollection{jaring_representing_2002,
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Representing {Variability} in {Software} {Product} {Lines}: {A} {Case} {Study}},
	copyright = {©2002 Springer-Verlag Berlin Heidelberg},
	isbn = {978-3-540-43985-1 978-3-540-45652-0},
	shorttitle = {Representing {Variability} in {Software} {Product} {Lines}},
	url = {http://link.springer.com/chapter/10.1007/3-540-45652-X_2},
	abstract = {Variability is the ability to change or customize a software system (i.e., software architects anticipate change and design architectures that support those changes). If the architecture is used for different product versions (e.g., in a software product line context, it becomes important to understand where change has to be planned and the possible options in particular situations. Three variability issues have been identified in a case study involving a software company specializing in product and system development for a professional mobile communication infrastructure. These issues are discussed and analyzed and illustrate the need for handling variability in a more explicit manner. To address this need, this paper suggests a method to represent and normalize variability in industrial software systems. The method is exemplified by applying it to the software product line of the aforementioned company.},
	number = {2379},
	urldate = {2016-07-04},
	booktitle = {Software {Product} {Lines}},
	publisher = {Springer Berlin Heidelberg},
	author = {Jaring, Michel and Bosch, Jan},
	editor = {Chastek, Gary J.},
	month = aug,
	year = {2002},
	note = {DOI: 10.1007/3-540-45652-X\_2},
	keywords = {IT in Business, Management of Computing and Information Systems, software engineering, The Computer Industry},
	pages = {15--36},
	file = {Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/MV22SB9X/Jaring and Bosch - 2002 - Representing Variability in Software Product Lines.pdf:application/pdf;Snapshot:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/NNWTR5J8/3-540-45652-X_2.html:text/html}
}

@article{mili_reusing_1995,
	title = {Reusing software: issues and research directions},
	volume = {21},
	issn = {00985589},
	shorttitle = {Reusing software},
	url = {http://ieeexplore.ieee.org/document/391379/},
	doi = {10.1109/32.391379},
	number = {6},
	urldate = {2016-11-01},
	journal = {IEEE Transactions on Software Engineering},
	author = {Mili, H. and Mili, F. and Mili, A.},
	month = jun,
	year = {1995},
	pages = {528--562}
}

@inproceedings{she_reverse_2011,
	series = {{ICSE} '11},
	title = {Reverse engineering feature models},
	doi = {10.1145/1985793.1985856},
	abstract = {Feature models describe the common and variable characteristics of a product line. Their advantages are well recognized in product line methods. Unfortunately, creating a feature model for an existing project is time-consuming and requires substantial effort from a modeler. We present procedures for reverse engineering feature models based on a crucial heuristic for identifying parents - the major challenge of this task. We also automatically recover constructs such as feature groups, mandatory features, and implies/excludes edges. We evaluate the technique on two large-scale software product lines with existing reference feature models–the Linux and eCos kernels–and FreeBSD, a project without a feature model. Our heuristic is effective across all three projects by ranking the correct parent among the top results for a vast majority of features. The procedures effectively reduce the information a modeler has to consider from thousands of choices to typically five or less.},
	booktitle = {Proceedings of the 33rd {International} {Conference} on {Software} {Engineering}},
	author = {She, S. and Lotufo, R. and Berger, T. and Wasowski, A. and Czarnecki, K.},
	year = {2011},
	keywords = {Biological system modeling, Buildings, eCos kernel, feature extraction, feature group, Feature models, feature similarity, FreeBSD, Image edge detection, implies-excludes edge, Linux, Linux kernel, mandatory feature, operating system kernels, product line method, reverse engineering, reverse engineering feature model, Semantics, software engineering, software product lines, Variability modeling},
	pages = {461 --470},
	file = {IEEE Xplore Abstract Record:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/59SCUCX8/login.html:text/html}
}

@article{becan_reverse_2013,
	title = {Reverse {Engineering} {Feature} {Models} in the {Real}},
	url = {http://dumas.ccsd.cnrs.fr/dumas-00855005},
	abstract = {Numerous organizations face the need to develop highly con figurable systems with thousands of functionalities and variable subsystems. Feature Models (FMs) are a popular formalism for modeling and reasoning about configurations of a system. As the manual construction or management of an FM is time-consuming, error-prone and not realistic for large software projects, automated operations for reverse engineering, slicing, diff , merging or refactoring FMs have been developed. With a basic strategy or without prior knowledge, these operations are likely to compute meaningless ontological relations (as defined by the hierarchy and feature groups) between features which may cause severe difficulties when reading, maintaining or exploiting the resulting FM. In this paper, we address the problem of synthesizing an FM both valid w.r.t. a set of logical dependencies (representing a set of configurations) while having an appropriate ontological semantics. We define a generic procedure and evaluate a series of heuristics for clustering and weighting the syntactic and semantic relationships between feature names to assist users in selecting a hierarchy and feature groups. We also present an interactive environment that use our techniques and offer a way to include the user's knowledge. The experiments on hundreds of realistic FMs show that our tool-supported procedures effectively reduce the information a user has to consider during the synthesis of an FM. This work is a necessary step for reverse engineering feature models in the real, i.e., in realistic projects whose variability is scattered in numerous artefacts and where developers may not have a global view of the project.},
	urldate = {2013-11-29},
	author = {Becan, Guillaume},
	month = jun,
	year = {2013},
	keywords = {feature model, reverse engineering, semantic similarity, software product line, Variability modeling},
	file = {Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/Z5S8P4DX/Becan - 2013 - Reverse Engineering Feature Models in the Real.pdf:application/pdf;Snapshot:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/R8RW9HT4/dumas-00855005.html:text/html}
}

@article{salomons_review_1993,
	title = {Review of research in feature-based design},
	volume = {12},
	issn = {02786125},
	url = {http://linkinghub.elsevier.com/retrieve/pii/027861259390012I},
	doi = {10.1016/0278-6125(93)90012-I},
	number = {2},
	urldate = {2016-10-11},
	journal = {Journal of Manufacturing Systems},
	author = {Salomons, O.W. and van Houten, F.J.A.M. and Kals, H.J.J.},
	month = jan,
	year = {1993},
	pages = {113--132}
}

@inproceedings{teixeira_safe_2011,
	title = {Safe {Composition} of {Configuration} {Knowledge}-{Based} {Software} {Product} {Lines}},
	isbn = {978-1-4577-2187-8},
	url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=6065124},
	doi = {10.1109/SBES.2011.15},
	urldate = {2014-07-15},
	booktitle = {25th {Brazilian} {Symposium} on {Software} {Engineering} ({SBES})},
	publisher = {IEEE},
	author = {Teixeira, Leopoldo and Borba, Paulo and Gheyi, Rohit},
	month = sep,
	year = {2011},
	pages = {263--272}
}

@article{neves_safe_2015,
	title = {Safe {Evolution} {Templates} for {Software} {Product} {Lines}},
	issn = {0164-1212},
	url = {http://www.sciencedirect.com/science/article/pii/S0164121215000801},
	doi = {10.1016/j.jss.2015.04.024},
	abstract = {Software product lines enable generating related software products from reusable assets. Adopting a product line strategy can bring significant quality and productivity improvements. However, evolving a product line can be risky, since it might impact many products. When introducing new features or improving its design, it is important to make sure that the behavior of existing products is not affected. To ensure that, one usually has to analyze different types of artifacts, an activity that can lead to errors. To address this issue, in this work we discover and analyze concrete evolution scenarios from five different product lines. We discover a total of 13 safe evolution templates, which are generic transformations that developers can apply when evolving compositional and annotative product lines, with the goal of preserving the behavior of existing products. We also evaluate the templates by analyzing the evolution history of these product lines. In this evaluation, we observe that the templates can address the modifications that developers performed in the analyzed scenarios, which corroborates the expressiveness of our template set. We also observe that the templates could also have helped to avoid the errors that we identified during our analysis.},
	urldate = {2015-05-08},
	journal = {Journal of Systems and Software},
	author = {Neves, L. and Borba, P. and Alves, V. and Turnes, L. and Teixeira, L. and Sena, D. and Kulesza, U.},
	year = {2015},
	keywords = {evolution, program and model transformation, program families, refactoring, refinement, software product lines},
	file = {ScienceDirect Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/UMEFRDG9/Neves et al. - Safe Evolution Templates for Software Product Line.pdf:application/pdf;ScienceDirect Snapshot:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/64W7C8TA/S0164121215000801.html:text/html}
}

@inproceedings{medeiros_safely_2015,
	title = {Safely evolving configurable systems},
	isbn = {978-1-4503-3722-9},
	url = {http://dl.acm.org/citation.cfm?doid=2814189.2815365},
	doi = {10.1145/2814189.2815365},
	urldate = {2016-01-22},
	publisher = {ACM Press},
	author = {Medeiros, Flávio},
	year = {2015},
	pages = {85--86}
}

@inproceedings{liebig_scalable_2013,
	series = {{ESEC}/{FSE} '13},
	title = {Scalable analysis of variable software},
	isbn = {978-1-4503-2237-9},
	url = {http://dl.acm.org/citation.cfm?doid=2491411.2491437},
	doi = {10.1145/2491411.2491437},
	urldate = {2016-01-29},
	booktitle = {Proceedings of the 2013 9th {Joint} {Meeting} on {Foundations} of {Software} {Engineering}},
	publisher = {ACM Press},
	author = {Liebig, Jörg and von Rhein, Alexander and Kästner, Christian and Apel, Sven and Dörre, Jens and Lengauer, Christian},
	year = {2013},
	pages = {81}
}

@article{siegmund_scalable_2013,
	title = {Scalable {Prediction} of {Non}-functional {Properties} in {Software} {Product} {Lines}: {Footprint} and {Memory} {Consumption}},
	issn = {0950-5849},
	shorttitle = {Scalable {Prediction} of {Non}-functional {Properties} in {Software} {Product} {Lines}},
	url = {http://www.sciencedirect.com/science/article/pii/S0950584912001541?v=s5},
	doi = {10.1016/j.infsof.2012.07.020},
	abstract = {Context
A software product line is a family of related software products, typically created from a set of common assets. Users select features to derive a product that fulfills their needs. Users often expect a product to have specific non-functional properties, such as a small footprint or a bounded response time. Because a product line may have an exponential number of products with respect to its features, it is usually not feasible to generate and measure non-functional properties for each possible product.
Objective
Our overall goal is to derive optimal products with respect to non-functional requirements by showing customers which features must be selected.
Method
We propose an approach to predict a product’s non-functional properties based on the product’s feature selection. We aggregate the influence of each selected feature on a non-functional property to predict a product’s properties. We generate and measure a small set of products and, by comparing measurements, we approximate each feature’s influence on the non-functional property in question. As a research method, we conducted controlled experiments and evaluated prediction accuracy for the non-functional properties footprint and main-memory consumption. But, in principle, our approach is applicable for all quantifiable non-functional properties.
Results
With nine software product lines, we demonstrate that our approach predicts the footprint with an average accuracy of 94 \%, and an accuracy of over 99 \% on average if feature interactions are known. In a further series of experiments, we predicted main memory consumption of six customizable programs and achieved an accuracy of 89 \% on average.
Conclusion
Our experiments suggest that, with only few measurements, it is possible to accurately predict non-functional properties of products of a product line. Furthermore, we show how already little domain knowledge can improve predictions and discuss trade-offs between accuracy and required number of measurements. With this technique, we provide a basis for many reasoning and product-derivation approaches.},
	number = {0},
	urldate = {2012-09-03},
	journal = {Information and Software Technology},
	author = {Siegmund, Norbert and Rosenmüller, Marko and Kästner, Christian and Giarrusso, Paolo G. and Apel, Sven and Kolesnikov, Sergiy S.},
	month = mar,
	year = {2013},
	keywords = {Measurement, Non-Functional Properties, Prediction, software product lines, SPL Conqueror},
	file = {ScienceDirect Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/8SDRD5ZV/Siegmund et al. - Scalable Prediction of Non-functional Properties i.pdf:application/pdf;ScienceDirect Snapshot:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/VKGVFJTZ/S0950584912001541.html:text/html}
}

@article{batory_scaling_2004,
	title = {Scaling step-wise refinement},
	volume = {30},
	issn = {0098-5589},
	url = {http://ieeexplore.ieee.org/document/1321059/},
	doi = {10.1109/TSE.2004.23},
	number = {6},
	urldate = {2016-10-31},
	journal = {IEEE Transactions on Software Engineering},
	author = {Batory, D. and Sarvela, J.N. and Rauschmayer, A.},
	month = jun,
	year = {2004},
	pages = {355--371}
}

@incollection{hutchison_search_2006,
	address = {Berlin, Heidelberg},
	title = {Search {Based} {Software} {Engineering}},
	volume = {3994},
	isbn = {978-3-540-34385-1 978-3-540-34386-8},
	url = {http://link.springer.com/10.1007/11758549_100},
	urldate = {2017-06-22},
	booktitle = {Computational {Science} ? {ICCS} 2006},
	publisher = {Springer Berlin Heidelberg},
	author = {Harman, Mark},
	editor = {Hutchison, David and Kanade, Takeo and Kittler, Josef and Kleinberg, Jon M. and Mattern, Friedemann and Mitchell, John C. and Naor, Moni and Nierstrasz, Oscar and Pandu Rangan, C. and Steffen, Bernhard and Sudan, Madhu and Terzopoulos, Demetri and Tygar, Dough and Vardi, Moshe Y. and Weikum, Gerhard and Alexandrov, Vassil N. and van Albada, Geert Dick and Sloot, Peter M. A. and Dongarra, Jack},
	year = {2006},
	note = {DOI: 10.1007/11758549\_100},
	pages = {740--747}
}

@inproceedings{kumara_sharing_2013,
	series = {{SCC} '13},
	title = {Sharing with a {Difference}: {Realizing} {Service}-{Based} {SaaS} {Applications} with {Runtime} {Sharing} and {Variation} in {Dynamic} {Software} {Product} {Lines}},
	isbn = {978-0-7695-5026-8},
	shorttitle = {Sharing with a {Difference}},
	url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=6649742},
	doi = {10.1109/SCC.2013.30},
	urldate = {2016-01-10},
	booktitle = {Proceedings of the {IEEE} {International} {Conference} on {Service} {Computing}},
	publisher = {IEEE},
	author = {Kumara, Indika and Han, Jun and Colman, Alan and Nguyen, Tuan and Kapuruge, Malinda},
	month = jun,
	year = {2013},
	pages = {567--574}
}

@inproceedings{bruntink_simple_2007,
	title = {Simple crosscutting concerns are not so simple: analysing variability in large-scale idioms-based implementations},
	isbn = {1-59593-615-7},
	shorttitle = {Simple crosscutting concerns are not so simple},
	url = {http://portal.acm.org/citation.cfm?doid=1218563.1218586},
	doi = {10.1145/1218563.1218586},
	urldate = {2015-07-06},
	publisher = {ACM Press},
	author = {Bruntink, Magiel and van Deursen, Arie and D'Hondt, Maja and Tourwé, Tom},
	year = {2007},
	pages = {199}
}

@book{bass_software_1998,
	title = {Software {Architecture} in {Practice}},
	publisher = {Addison-Weasley},
	author = {Bass, L. and Clements, P. and Kazman, R.},
	year = {1998}
}

@article{cataldo_software_2009,
	title = {Software {Dependencies}, {Work} {Dependencies}, and {Their} {Impact} on {Failures}},
	volume = {35},
	issn = {0098-5589},
	doi = {10.1109/TSE.2009.42},
	abstract = {Prior research has shown that customer-reported software faults are often the result of violated dependencies that are not recognized by developers implementing software. Many types of dependencies and corresponding measures have been proposed to help address this problem. The objective of this research is to compare the relative performance of several of these dependency measures as they relate to customer-reported defects. Our analysis is based on data collected from two projects from two independent companies. Combined, our data set encompasses eight years of development activity involving 154 developers. The principal contribution of this study is the examination of the relative impact that syntactic, logical, and work dependencies have on the failure proneness of a software system. While all dependencies increase the fault proneness, the logical dependencies explained most of the variance in fault proneness, while workflow dependencies had more impact than syntactic dependencies. These results suggest that practices such as rearchitecting, guided by the network structure of logical dependencies, hold promise for reducing defects.},
	number = {6},
	journal = {IEEE Transactions on Software Engineering},
	author = {Cataldo, M. and Mockus, A. and Roberts, J.A. and Herbsleb, J.D.},
	month = nov,
	year = {2009},
	keywords = {customer-reported software faults, Distribution/maintenance/enhancement, metrics/measurement, organizational management and coordination, quality analysis, quality analysis and evaluation., software dependencies, software fault tolerance, software maintenance, software metrics, software quality, work dependencies},
	pages = {864--878},
	file = {IEEE Xplore Abstract Record:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/NUIN7IMS/abs_all.html:text/html;IEEE Xplore Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/QTEPVCWS/Cataldo et al. - 2009 - Software Dependencies, Work Dependencies, and Thei.pdf:application/pdf}
}

@article{potts_software_1993,
	title = {Software engineering research revisited},
	volume = {10},
	number = {5},
	journal = {IEEE Software},
	author = {Potts, Colin},
	year = {1993},
	pages = {19--28}
}

@book{pohl_software_2005,
	title = {Software {Product} {Line} {Engineering}: {Foundations}, {Principles} and {Techniques}},
	isbn = {3-540-24372-0},
	shorttitle = {Software {Product} {Line} {Engineering}},
	publisher = {Springer-Verlag},
	author = {Pohl, Klaus and Böckle, Günter and Linden, Frank J. van der},
	year = {2005}
}

@book{clements_software_2002,
	address = {Reading, MA},
	title = {Software {Product} {Lines}, 2nd edition},
	publisher = {Addison-Weasley},
	author = {Clements, P. and Northorp, L.},
	year = {2002}
}

@book{bosch_software_2010,
	address = {Berlin ; New York},
	series = {Lecture notes in computer science},
	title = {Software product lines: going beyond: 14th international conference, {SPLC} 2010, {Jeju} {Island}, {South} {Korea}, {September} 13-17, 2010: proceedings},
	isbn = {978-3-642-15578-9},
	shorttitle = {Software product lines},
	number = {6287},
	publisher = {Springer},
	editor = {Bosch, Jan and Lee, Jaejoon},
	year = {2010},
	keywords = {Computer software, Congrès, development, Génie logiciel, Logiciel, Logiciels Développement Congrès, software engineering}
}

@book{clements_software_2002-1,
	address = {Boston},
	series = {The {SEI} series in software engineering},
	title = {Software product lines: practices and patterns},
	isbn = {0-201-70332-7},
	shorttitle = {Software product lines},
	publisher = {Addison-Wesley},
	author = {Clements, Paul},
	collaborator = {Northrop, Linda},
	year = {2002},
	keywords = {Computer software, development}
}

@article{ommering_software_2005,
	title = {Software {Reuse} in {Product} {Populations}},
	volume = {31},
	issn = {0098-5589},
	doi = {10.1109/TSE.2005.84},
	abstract = {Consumer products are becoming increasingly software intensive. The software complexity of individual products grows, while the diversity of products increases and the lead time must decrease. Software reuse is the answer to this, not only within a family but also between families of consumer products. We have devised an approach based upon a software component technology to enable reuse. This paper describes that approach, and it zooms in on two important aspects of component-based development. One aspect concerns the prediction of system properties from properties of components, which we illustrate using thread synchronization as example. The other aspect concerns branching of our software in our configuration management systems, where our analysis leads to the discovery that we may be constantly rewriting our own code and to the definition of the turn-over factor to quantify this. We end this paper with a brief validation of our approach.},
	number = {7},
	journal = {IEEE Transactions on Software Engineering},
	author = {Ommering, Rob van},
	month = jul,
	year = {2005},
	keywords = {component-based software architectures, index terms- software reuse, software components, software product families, software product lines.},
	pages = {537--550},
	file = {IEEE Computer Snapshot:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/GS2GIMRJ/e0537-abs.html:text/html}
}

@book{rozanski_software_2011,
	title = {Software {Systems} {Architecture}: {Working} with {Stakeholders} {Using} {Viewpoints} and {Perspectives}},
	isbn = {978-0-321-71833-4},
	shorttitle = {Software {Systems} {Architecture}},
	abstract = {Software Systems Architecture, Second Edition is a highly regarded, practitioner-oriented guide to designing and implementing effective architectures for information systems. It is both a readily accessible introduction to software architecture and an invaluable handbook of well-established best practices.   With this book you will learn how to  Design and communicate an architecture that reflects and balances the different needs of its stakeholders  Focus on architecturally significant aspects of design, including frequently overlooked areas such as performance, resilience, and location  Use scenarios and patterns to drive the creation and validation of your architecture  Document your architecture as a set of related views    Reflecting new standards and developments in the field, this new edition extends and updates much of the content, and  Adds a “system context viewpoint” that documents the system's interactions with its environment  Expands the discussion of architectural principles, showing how they can be used to provide traceability and rationale for architectural decisions  Explains how agile development and architecture can work together  Positions requirements and architecture activities in the project context  Presents a new lightweight method for architectural validation    Whether you are an aspiring or practicing software architect, you will find yourself referring repeatedly to the practical advice in this book throughout the lifecycle of your projects. A supporting Web site containing further information can be found at www.viewpoints-and-perspectives.info.},
	publisher = {Addison-Wesley},
	author = {Rozanski, Nick and Woods, Eoin},
	month = oct,
	year = {2011},
	note = {Google-Books-ID: ka4QO9kXQFUC},
	keywords = {Computers / General, Computers / Software Development \& Engineering / General}
}

@article{fournier-viger_spmf:_2014,
	title = {{SPMF}: {A} {Java} {Open}-source {Pattern} {Mining} {Library}},
	volume = {15},
	issn = {1532-4435},
	shorttitle = {{SPMF}},
	url = {http://dl.acm.org/citation.cfm?id=2627435.2750353},
	abstract = {We present SPMF, an open-source data mining library offering implementations of more than 55 data mining algorithms. SPMF is a cross-platform library implemented in Java, specialized for discovering patterns in transaction and sequence databases such as frequent itemsets, association rules and sequential patterns. The source code can be integrated in other Java programs. Moreover, SPMF offers a command line interface and a simple graphical interface for quick testing. The source code is available under the GNU General Public License, version 3. The website of the project offers several resources such as documentation with examples of how to run each algorithm, a developer's guide, performance comparisons of algorithms, data sets, an active forum, a FAQ and a mailing list.},
	number = {1},
	urldate = {2015-08-25},
	journal = {J. Mach. Learn. Res.},
	author = {Fournier-Viger, Philippe and Gomariz, Antonio and Gueniche, Ted and Soltani, Azadeh and Wu, Cheng-Wei and Tseng, Vincent S.},
	month = jan,
	year = {2014},
	keywords = {data mining, frequent pattern mining, library, open-source, sequence database, transaction database},
	pages = {3389--3393},
	file = {ACM Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/XEDJBMDF/Fournier-Viger et al. - 2014 - SPMF A Java Open-source Pattern Mining Library.pdf:application/pdf}
}

@article{czarnecki_staged_2005,
	title = {Staged configuration through specialization and multilevel configuration of feature models},
	volume = {10},
	copyright = {Copyright © 2005 John Wiley \& Sons, Ltd.},
	issn = {1099-1670},
	shorttitle = {Softw. {Process}: {Improve}. {Pract}.},
	doi = {10.1002/spip.225},
	abstract = {Feature modeling is a key technique for capturing commonalities and variabilities in system families and product lines. In this article, we propose a cardinality-based notation for feature modeling, which integrates a number of existing extensions of previous approaches. We then introduce and motivate the novel concept of staged configuration. Staged configuration can be achieved by the stepwise specialization of feature models or by multilevel configuration, where the configuration choices available in each stage are defined by separate feature models. Staged configuration is important because, in a realistic development process, different groups and different people make product configuration choices in different stages. Finally, we also discuss how multilevel configuration avoids a breakdown between the different abstraction levels of individual features. This problem, sometimes referred to as 'analysis paralysis', easily occurs in feature modeling because features can denote entities at arbitrary levels of abstraction within a system family. Copyright © 2005 John Wiley \& Sons, Ltd.},
	number = {2},
	urldate = {2013-12-11},
	journal = {Software Process: Improvement and Practice},
	author = {Czarnecki, Krzysztof and Helsen, Simon and Eisenecker, Ulrich},
	month = apr,
	year = {2005},
	keywords = {domain analysis, software configuration, software product lines, system families},
	pages = {143--169},
	file = {Snapshot:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/73FAF4UZ/abstract\;jsessionid=7B0B75B965D0BF3818875885C7B12F92.html:text/html}
}

@inproceedings{czarnecki_staged_2004,
	series = {{SPLC} '04},
	title = {Staged {Configuration} {Using} {Feature} {Models}},
	copyright = {©2004 Springer-Verlag Berlin Heidelberg},
	isbn = {978-3-540-22918-6 978-3-540-28630-1},
	abstract = {Feature modeling is an important approach to capturing commonalities and variabilities in system families and product lines. In this paper, we propose a cardinality-based notation for feature modeling, which integrates a number of existing extensions of previous approaches. We then introduce and motivate the novel concept of staged configuration. Staged configuration can be achieved by the stepwise specialization of feature models. This is important because in a realistic development process, different groups and different people eliminate product variability in different stages. We also indicate how cardinality-based feature models and their specialization can be given a precise formal semantics.},
	urldate = {2013-04-21},
	booktitle = {Proc. of the {Third} {International} {Conference} {Software} {Product} {Lines}},
	publisher = {Springer-Verlag},
	author = {Czarnecki, Krzysztof and Helsen, Simon and Eisenecker, Ulrich},
	editor = {Nord, Robert L.},
	year = {2004},
	keywords = {Computers and Society, Management of Computing and Information Systems, software engineering},
	pages = {266--283},
	file = {Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/CQ8HHZ4S/Czarnecki et al. - 2004 - Staged Configuration Using Feature Models.pdf:application/pdf;Snapshot:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/X6PAVX9M/978-3-540-28630-1_17.html:text/html}
}

@article{dhungana_structuring_2010,
	title = {Structuring the modeling space and supporting evolution in software product line engineering},
	volume = {83},
	issn = {0164-1212},
	url = {http://www.sciencedirect.com/science/article/pii/S0164121210000506},
	doi = {10.1016/j.jss.2010.02.018},
	abstract = {The scale and complexity of product lines means that it is practically infeasible to develop a single model of the entire system, regardless of the languages or notations used. The dynamic nature of real-world systems means that product line models need to evolve continuously to meet new customer requirements and to reflect changes of product line artifacts. To address these challenges, product line engineers need to apply different strategies for structuring the modeling space to ease the creation and maintenance of models. This paper presents an approach that aims at reducing the maintenance effort by organizing product lines as a set of interrelated model fragments defining the variability of particular parts of the system. We provide support to semi-automatically merge fragments into complete product line models. We also provide support to automatically detect inconsistencies between product line artifacts and the models representing these artifacts after changes. Furthermore, our approach supports the co-evolution of models and their respective meta-models. We discuss strategies for structuring the modeling space and show the usefulness of our approach using real-world examples from our ongoing industry collaboration.},
	number = {7},
	urldate = {2012-07-04},
	journal = {Journal of Systems and Software},
	author = {Dhungana, Deepak and Grünbacher, Paul and Rabiser, Rick and Neumayer, Thomas},
	month = jul,
	year = {2010},
	keywords = {Model evolution, Product line engineering, Variability modeling},
	pages = {1108--1122},
	file = {ScienceDirect Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/AWIG55XS/Dhungana et al. - 2010 - Structuring the modeling space and supporting evol.pdf:application/pdf;ScienceDirect Snapshot:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/PSDDB8HA/S0164121210000506.html:text/html}
}

@inproceedings{marsavina_studying_2014,
	series = {{SCAM} '14},
	title = {Studying {Fine}-{Grained} {Co}-evolution {Patterns} of {Production} and {Test} {Code}},
	isbn = {978-1-4799-6148-1},
	url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=6975653},
	doi = {10.1109/SCAM.2014.28},
	urldate = {2015-07-22},
	booktitle = {Proceedings of the 14th {International} {Working} {Conference} on {Source} {Code} {Analysis} and {Manipulation}},
	publisher = {IEEE},
	author = {Marsavina, Cosmin and Romano, Daniele and Zaidman, Andy},
	year = {2014},
	pages = {195--204}
}

@inproceedings{riebisch_supporting_2004,
	title = {Supporting evolutionary development by feature models and traceability links},
	doi = {10.1109/ECBS.2004.1316721},
	abstract = {During their usage, software systems have to be changed constantly. If such changes are implemented in an incomplete or inconsistent way a loss of architectural quality will occur, i.e. in terms of maintainability and understandability. The lack of traceability of the impact of changed requirements in the software enhances this effect. Traceability links have been proposed as a link between the requirements and the different parts of a solution. In practical use, these links are difficult to establish and maintain. Currently, tools cannot effectively support these links due to human-required decisions. This paper introduces feature models as an intermediate element for linking requirements to design models. They enable a more appropriate bridging of the different levels of abstraction. Feature models group sets of requirements to a feature and enable a modeling of the variability of requirements. The feature models structure traceability links between requirements, design elements and implementation parts. This leads to lower efforts of establishing and maintaining the links. Furthermore, descriptions of design decisions can be attached to the links. Industrial experience with this approach shows its support for the evolutionary development of large software systems, especially in the improved comprehension of the changes by the developers.},
	booktitle = {Engineering of {Computer}-{Based} {Systems}, 2004. {Proceedings}. 11th {IEEE} {International} {Conference} and {Workshop} on the},
	author = {Riebisch, Matthias},
	month = may,
	year = {2004},
	keywords = {Computer industry, Control systems, Documentation, Electrical equipment industry, Feature models, formal specification, Frequency, industrial control, Joining processes, Process control, Software architecture, software design elements, software development management, software evolutionary development, software maintenance, Software prototyping, software reusability, software systems, software tools, traceability links},
	pages = {370--377},
	file = {IEEE Xplore Abstract Record:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/DVWFID83/abs_all.html:text/html;IEEE Xplore Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/4EVD58NT/Riebisch - 2004 - Supporting evolutionary development by feature mod.pdf:application/pdf}
}

@inproceedings{vidacs_supporting_2015,
	title = {Supporting software product line testing by optimizing code configuration coverage},
	doi = {10.1109/ICSTW.2015.7107478},
	abstract = {Software product lines achieve much shorter time to market by system level reuse and code variability. A possible way to achieve this flexibility is to use generic components, including the core system, in different products in alternative configurations. The focus of testing efforts for such complex and highly variable systems often shifts from testing specific products to assessing the overall quality of the core system or potential new configurations. As a complementary approach to feature models and related combinatorial testing methods optimizing for feature coverage, we apply a source code oriented analysis of variability. We present two algorithms that optimize for high coverage of the common code base in terms of C++ preprocessor-based configurations with a limited set of actual configurations selected for testing. The methods have been evaluated on iGO Navigation, a large industrial system with typical configuration support for product lines, hence we believe the approach can be generalized to other systems as well.},
	booktitle = {2015 {IEEE} {Eighth} {International} {Conference} on {Software} {Testing}, {Verification} and {Validation} {Workshops} ({ICSTW})},
	author = {Vidacs, L. and Horvath, F. and Mihalicza, J. and Vancsics, B. and Beszedes, A},
	month = apr,
	year = {2015},
	keywords = {Algorithm design and analysis, analytical models, C++ language, C++ preprocessor-based configuration, code configuration coverage optimization, code variability, combinatorial testing method, Configurations, core system quality, Electronic mail, Frequency modulation, iGO navigation, Navigation, Preprocessor, program testing, software, software product line, software product lines, software product line testing, source code oriented analysis, source code (software), Testing, variability, White box testing},
	pages = {1--7},
	file = {IEEE Xplore Abstract Record:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/RAPJJABD/7107478.html:text/html;IEEE Xplore Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/C385IHUX/Vidács et al. - 2015 - Supporting software product line testing by optimi.pdf:application/pdf}
}

@incollection{nebut_system_2006,
	title = {System {Testing} of {Product} {Lines}: {From} {Requirements} to {Test} {Cases}},
	copyright = {©2006 Springer-Verlag Berlin Heidelberg},
	isbn = {978-3-540-33252-7 978-3-540-33253-4},
	shorttitle = {System {Testing} of {Product} {Lines}},
	urldate = {2014-03-10},
	booktitle = {Software {Product} {Lines}},
	publisher = {Springer Berlin Heidelberg},
	author = {Nebut, Clémentine and Traon, Yves Le and Jezequel, Jean-Marc},
	editor = {Käköla, Timo and Duenas, Juan Carlos},
	month = jan,
	year = {2006},
	keywords = {Business Information Systems, R \& D/Technology Policy, software engineering, Technology Management},
	pages = {447--477},
	file = {Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/3VM3I4II/Nebut et al. - 2006 - System Testing of Product Lines From Requirements.pdf:application/pdf;Snapshot:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/PHAHHNAA/10.html:text/html}
}

@inproceedings{fogdal_ten_2016,
	title = {Ten years of product line engineering at {Danfoss}: lessons learned and way ahead},
	isbn = {978-1-4503-4050-2},
	shorttitle = {Ten years of product line engineering at {Danfoss}},
	url = {http://dl.acm.org/citation.cfm?doid=2934466.2934491},
	doi = {10.1145/2934466.2934491},
	urldate = {2016-11-15},
	publisher = {ACM Press},
	author = {Fogdal, Thomas and Scherrebeck, Helene and Kuusela, Juha and Becker, Martin and Zhang, Bo},
	year = {2016},
	pages = {252--261}
}

@article{adams_evolution_2008,
	title = {The {Evolution} of the {Linux} {Build} {System}},
	volume = {8},
	copyright = {Copyright (c)},
	issn = {1863-2122},
	url = {http://journal.ub.tu-berlin.de/eceasst/article/view/115},
	abstract = {Software evolution entails more than just redesigning and reimplementing functionality of, fixing bugs in, or adding new features to source code. These evolutionary forces induce similar changes on the software's build system too, with far-reaching consequences on both overall developer productivity as well as software configurability. In this paper we take a look at this phenomenon in the Linux kernel from its inception up until present day. We do this by analysing the kernel's build traces with MAKAO, our re(verse)-engineering framework for build systems. This helps us in detecting interesting idioms and patterns in the dynamic build behaviour. Finding a good balance between obtaining a fast, correct build system and migrating in a stepwise fashion turns out to be the general theme throughout the evolution of the Linux build system.},
	number = {0},
	urldate = {2015-03-20},
	journal = {Electronic Communications of the EASST},
	author = {Adams, Bram and Schutter, Kris De and Tromp, Herman and Meuter, Wolfgang De},
	month = feb,
	year = {2008},
	file = {Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/6XVP6QRG/Adams et al. - 2008 - The Evolution of the Linux Build System.pdf:application/pdf;Snapshot:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/3BR7U2K8/115.html:text/html}
}

@article{israeli_linux_2010,
	title = {The {Linux} kernel as a case study in software evolution},
	volume = {83},
	issn = {0164-1212},
	url = {http://dx.doi.org/10.1016/j.jss.2009.09.042},
	doi = {10.1016/j.jss.2009.09.042},
	abstract = {We use 810 versions of the Linux kernel, released over a period of 14years, to characterize the system's evolution, using Lehman's laws of software evolution as a basis. We investigate different possible interpretations of these laws, as reflected by different metrics that can be used to quantify them. For example, system growth has traditionally been quantified using lines of code or number of functions, but functional growth of an operating system like Linux can also be quantified using the number of system calls. In addition we use the availability of the source code to track metrics, such as McCabe's cyclomatic complexity, that have not been tracked across so many versions previously. We find that the data supports several of Lehman's laws, mainly those concerned with growth and with the stability of the process. We also make some novel observations, e.g. that the average complexity of functions is decreasing with time, but this is mainly due to the addition of many small functions.},
	number = {3},
	urldate = {2013-04-28},
	journal = {J. Syst. Softw.},
	author = {Israeli, Ayelet and Feitelson, Dror G.},
	year = {2010},
	keywords = {Lehman's laws, Linux kernel, software evolution},
	pages = {485--501}
}

@article{sincero_linux_2008,
	title = {The linux kernel configurator as a feature modeling tool},
	url = {http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.157.2318&rep=rep1&type=pdf},
	urldate = {2013-02-08},
	journal = {SPLC},
	author = {Sincero, J. and Schröder-Preikschat, W.},
	year = {2008},
	pages = {257--260},
	file = {The Linux Kernel Configurator as a Feature Modeling Tool.pdf:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/6JQ6C9XM/The Linux Kernel Configurator as a Feature Modeling Tool.pdf:application/pdf}
}

@inproceedings{nelson_margrave_2010,
	address = {Berkeley, CA, USA},
	series = {{LISA}'10},
	title = {The {Margrave} {Tool} for {Firewall} {Analysis}},
	url = {http://dl.acm.org/citation.cfm?id=1924976.1924980},
	abstract = {Writing and maintaining firewall configurations can be challenging, even for experienced system administrators. Tools that uncover the consequences of configurations and edits to them can help sysadmins prevent subtle yet serious errors. Our tool, Margrave, offers powerful features for firewall analysis, including enumerating consequences of configuration edits, detecting overlaps and conflicts among rules, tracing firewall behavior to specific rules, and verification against security goals. Margrave differs from other firewall-analysis tools in supporting queries at multiple levels (rules, filters, firewalls, and networks of firewalls), comparing separate firewalls in a single query, supporting reflexive ACLs, and presenting exhaustive sets of concrete scenarios that embody queries. Margrave supports real-world firewall-configuration languages, decomposing them into multiple policies that capture different aspects of firewall functionality. We present evaluation on networking-forum posts and on an in-use enterprise firewall-configuration.},
	urldate = {2015-02-14},
	booktitle = {Proceedings of the 24th {International} {Conference} on {Large} {Installation} {System} {Administration}},
	publisher = {USENIX Association},
	author = {Nelson, Timothy and Barratt, Christopher and Dougherty, Daniel J. and Fisler, Kathi and Krishnamurthi, Shriram},
	year = {2010},
	pages = {1--8}
}

@inproceedings{godfrey_past_2008,
	title = {The past, present, and future of software evolution},
	doi = {10.1109/FOSM.2008.4659256},
	abstract = {Change is an essential characteristic of software development, as software systems must respond to evolving requirements, platforms, and other environmental pressures. In this paper, we discuss the concept of software evolution from several perspectives. We examine how it relates to and differs from software maintenance. We discuss insights about software evolution arising from Lehmanpsilas laws of software evolution and the staged lifecycle model of Bennett and Rajlich. We compare software evolution to other kinds of evolution, from science and social sciences, and we examine the forces that shape change. Finally, we discuss the changing nature of software in general as it relates to evolution, and we propose open challenges and future directions for software evolution research.},
	booktitle = {Frontiers of {Software} {Maintenance}, 2008. {FoSM} 2008.},
	author = {Godfrey, M.W. and German, D.M.},
	year = {2008},
	keywords = {Computer Science, Environmental economics, Evolution (biology), lifecycle model, Preventive maintenance, Runtime environment, software development, software development management, software engineering, software evolution, software maintenance, Software standards, software systems, Taxonomy},
	pages = {129--138},
	file = {IEEE Xplore Abstract Record:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/RHE9DXV3/abs_all.html:text/html;IEEE Xplore Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/DGKWUPME/Godfrey and German - 2008 - The past, present, and future of software evolutio.pdf:application/pdf}
}

@inproceedings{bird_promises_2009,
	title = {The promises and perils of mining git},
	doi = {10.1109/MSR.2009.5069475},
	abstract = {We are now witnessing the rapid growth of decentralized source code management (DSCM) systems, in which every developer has her own repository. DSCMs facilitate a style of collaboration in which work output can flow sideways (and privately) between collaborators, rather than always up and down (and publicly) via a central repository. Decentralization comes with both the promise of new data and the peril of its misinterpretation. We focus on git, a very popular DSCM used in high-profile projects. Decentralization, and other features of git, such as automatically recorded contributor attribution, lead to richer content histories, giving rise to new questions such as ldquoHow do contributions flow between developers to the official project repository?rdquo However, there are pitfalls. Commits may be reordered, deleted, or edited as they move between repositories. The semantics of terms common to SCMs and DSCMs sometimes differ markedly, potentially creating confusion. For example, a commit is immediately visible to all developers in centralized SCMs, but not in DSCMs. Our goal is to help researchers interested in DSCMs avoid these and other perils when mining and analyzing git data.},
	booktitle = {6th {IEEE} {International} {Working} {Conference} on {Mining} {Software} {Repositories}, 2009. {MSR} '09},
	author = {Bird, C. and Rigby, P.C. and Barr, E.T. and Hamilton, D.J. and German, D.M. and Devanbu, P.},
	year = {2009},
	keywords = {automatically recorded contributor attribution, Birds, central repository, collaboration, Collaborative work, data analysis, data mining, decentralization, decentralized source code management systems, groupware, History, Kernel, Linux, Mercury (metals), mining git, Open source software, Packaging, Rails},
	pages = {1--10},
	file = {IEEE Xplore Abstract Record:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/2K4EERFM/abs_all.html:text/html;IEEE Xplore Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/HHMFVFN8/Bird et al. - 2009 - The promises and perils of mining git.pdf:application/pdf}
}

@incollection{reuys_scented_2006,
	title = {The {ScenTED} {Method} for {Testing} {Software} {Product} {Lines}},
	copyright = {©2006 Springer-Verlag Berlin Heidelberg},
	isbn = {978-3-540-33252-7 978-3-540-33253-4},
	urldate = {2014-03-10},
	booktitle = {Software {Product} {Lines}},
	publisher = {Springer Berlin Heidelberg},
	author = {Reuys, Andreas and Reis, Sacha and Kamsties, Erik and Pohl, Klaus},
	editor = {Käköla, Timo and Duenas, Juan Carlos},
	year = {2006},
	keywords = {Business Information Systems, R \& D/Technology Policy, software engineering, Technology Management},
	pages = {479--520},
	file = {Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/VAGW49IT/Reuys et al. - 2006 - The ScenTED Method for Testing Software Product Li.pdf:application/pdf;Snapshot:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/9GJNVQNS/10.html:text/html}
}

@inproceedings{she_variability_2010,
	series = {{VaMoS} '10},
	title = {The {Variability} {Model} of {The} {Linux} {Kernel}.},
	url = {http://gsd.uwaterloo.ca/sites/default/files/camera-vamos-20100107.pdf},
	urldate = {2013-07-24},
	booktitle = {Proceedings of the 4th {International} {Workshop} on {Variability} {Modeling} of {Software}-intensive {Systems}},
	author = {She, Steven and Lotufo, Rafael and Berger, Thorsten and Wasowski, Andrzej and Czarnecki, Krzysztof},
	year = {2010},
	pages = {45--51},
	file = {She et al. - 2010 - The variability model of the linux kernel.pdf:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/FS87MV37/She et al. - 2010 - The variability model of the linux kernel.pdf:application/pdf}
}

@inproceedings{passos_towards_2012,
	series = {{FOSD} '12},
	title = {Towards a catalog of variability evolution patterns: the {Linux} kernel case},
	isbn = {978-1-4503-1309-4},
	shorttitle = {Towards a catalog of variability evolution patterns},
	url = {http://doi.acm.org/10.1145/2377816.2377825},
	doi = {10.1145/2377816.2377825},
	abstract = {A complete understanding of evolution of variability requires analysis over all project spaces that contain it: source code, build system and the variability model. Aiming at better understanding of how complex variant-rich software evolve, we set to study one, the Linux kernel, in detail. We qualitatively analyze a number of evolution steps in the kernel history and present our findings as a preliminary sample of a catalog of evolution patterns. Our patterns focus on how the variability evolves when features are removed from the variability model, but are kept as part of the software. The identified patterns relate changes to the variability model, the build system, and implementation code. Despite preliminary, they already indicate evolution steps that have not been captured by prior studies, both empirical and theoretical.},
	urldate = {2013-10-08},
	booktitle = {Proceedings of the 4th {International} {Workshop} on {Feature} {Oriented} {Software} {Development}},
	publisher = {ACM},
	author = {Passos, Leonardo and Czarnecki, Krzysztof and Wasowski, Andrzej},
	year = {2012},
	keywords = {evolution, Linux, patterns, software product lines, variability},
	pages = {62--69},
	file = {ACM Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/S83WW9WV/Passos et al. - 2012 - Towards a catalog of variability evolution pattern.pdf:application/pdf}
}

@inproceedings{oliva_towards_2011,
	title = {Towards a classification of logical dependencies origins: a case study},
	isbn = {978-1-4503-0848-9},
	shorttitle = {Towards a classification of logical dependencies origins},
	url = {http://dl.acm.org/citation.cfm?doid=2024445.2024452},
	doi = {10.1145/2024445.2024452},
	urldate = {2014-10-07},
	publisher = {ACM Press},
	author = {Oliva, Gustavo A. and Santana, Francisco W.S. and Gerosa, Marco A. and de Souza, Cleidson R.B.},
	year = {2011},
	pages = {31},
	file = {Oliva - Towards a Classification of Logical Dependencies Origins.pdf:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/X8BQZUNE/Oliva - Towards a Classification of Logical Dependencies Origins.pdf:application/pdf}
}

@inproceedings{benlarabi_towards_2014,
	title = {Towards a co-evolution model for software product lines based on cladistics},
	isbn = {978-1-4799-2393-9},
	url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=6861084},
	doi = {10.1109/RCIS.2014.6861084},
	urldate = {2015-06-01},
	publisher = {IEEE},
	author = {Benlarabi, Anissa},
	month = may,
	year = {2014},
	pages = {1--6}
}

@inproceedings{guo_towards_2010,
	address = {Berlin, Heidelberg},
	series = {{SPLC}'10},
	title = {Towards {Consistent} {Evolution} of {Feature} {Models}},
	isbn = {3-642-15578-2 978-3-642-15578-9},
	url = {http://dl.acm.org/citation.cfm?id=1885639.1885684},
	abstract = {This paper explores the possibility of consistent evolution of feature models (FMs), which should resolve the requested changes and maintain the consistency of FMs. According to the definition of FMs, we first analyze the primitive elements of FMs and suggest a set of atomic operations on FMs. Then we analyze and apply the semantics of change to FMs to support consistency maintenance during FMs evolution. The resolution of a requested change to an FM requires obtaining and executing a sequence of additional changes derived from the requested change for keeping the consistency of the FM. Our approach limits the consistency maintenance of an FM in a local range affected only by the requested change instead of the whole FM, which reduces the effort and improves the efficiency for the evolution and maintenance of FMs.},
	urldate = {2015-02-16},
	booktitle = {Proceedings of the 14th {International} {Conference} on {Software} {Product} {Lines}: {Going} {Beyond}},
	publisher = {Springer-Verlag},
	author = {Guo, Jianmei and Wang, Yinglin},
	year = {2010},
	pages = {451--455}
}

@inproceedings{schroter_towards_2013,
	title = {Towards {Modular} {Analysis} of {Multi} {Product} {Lines}},
	isbn = {978-1-4503-2325-3},
	doi = {10.1145/2499777.2500719},
	abstract = {Software product-line engineering enables efficient development of tailor-made software by means of reusable artifacts. As practitioners increasingly develop software systems as product lines, there is a growing potential to reuse product lines in other product lines, which we refer to as multi product line. We identify challenges when developing multi product lines and propose interfaces for different levels of abstraction ranging from variability modeling to functional and non-functional properties. We argue that these interfaces ease the reuse of product lines and identify research questions that need to be solved toward modular analysis of multi product lines.},
	urldate = {2014-02-17},
	booktitle = {Proc. of the 17th {International} {Software} {Product} {Line} {Conference} {Co}-located {Workshops}},
	publisher = {ACM},
	author = {Schröter, Reimar and Siegmund, Norbert and Thüm, Thomas},
	year = {2013},
	pages = {96--99},
	file = {ACM Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/HGXUPH4X/Schröter et al. - 2013 - Towards Modular Analysis of Multi Product Lines.pdf:application/pdf}
}

@inproceedings{kenner_typechef:_2010,
	address = {New York, NY, USA},
	series = {{FOSD} '10},
	title = {{TypeChef}: {Toward} {Type} {Checking} \#{Ifdef} {Variability} in {C}},
	isbn = {978-1-4503-0208-1},
	shorttitle = {{TypeChef}},
	url = {http://doi.acm.org/10.1145/1868688.1868693},
	doi = {10.1145/1868688.1868693},
	abstract = {Software product lines have gained momentum as an approach to generate many variants of a program, each tailored to a specific use case, from a common code base. However, the implementation of product lines raises new challenges, as potentially millions of program variants are developed in parallel. In prior work, we and others have developed product-line-aware type systems to detect type errors in a product line, without generating all variants. With TypeChef, we build a similar type checker for product lines written in C that implements variability with \#ifdef directives of the C preprocessor. However, a product-line-aware type system for C is more difficult than expected due to several peculiarities of the preprocessor, including lexical macros and unrestricted use of \#ifdef directives. In this paper, we describe the problems faced and our progress to solve them with TypeChef. Although TypeChef is still under development and cannot yet process arbitrary C code, we demonstrate its capabilities so far with a case study: By type checking the open-source web server Boa with potentially 2110 variants, we found type errors in several variants.},
	urldate = {2015-02-15},
	booktitle = {Proceedings of the 2nd {International} {Workshop} on {Feature}-{Oriented} {Software} {Development}},
	publisher = {ACM},
	author = {Kenner, Andy and Kästner, Christian and Haase, Steffen and Leich, Thomas},
	year = {2010},
	keywords = {\#ifdef, C, conditional compilation, cpp, disciplined annotations, partial preprocessor, type system},
	pages = {25--32},
	file = {ACM Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/PE8IJR9I/Kenner et al. - 2010 - TypeChef Toward Type Checking #Ifdef Variability .pdf:application/pdf}
}

@inproceedings{dietrich_understanding_2012,
	series = {{MISS}'12},
	title = {Understanding {Linux} feature distribution},
	url = {http://dl.acm.org/citation.cfm?id=2162030},
	urldate = {2013-08-23},
	booktitle = {Proceedings of the 2012 workshop on {Modularity} in {Systems} {Software}},
	publisher = {ACM},
	author = {Dietrich, Christian and Tartler, Reinhard and Schröder-Preikshat, Wolfgang and Lohmann, Daniel},
	year = {2012},
	pages = {15--20},
	file = {Dietrich et al. - 2012 - Understanding Linux variability .pdf:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/878DU44W/Dietrich et al. - 2012 - Understanding Linux variability .pdf:application/pdf}
}

@inproceedings{hartmann_using_2008,
	series = {{SPLC} '08},
	title = {Using {Feature} {Diagrams} with {Context} {Variability} to {Model} {Multiple} {Product} {Lines} for {Software} {Supply} {Chains}},
	doi = {10.1109/SPLC.2008.15},
	abstract = {Feature modeling is a key concept in product line engineering. Due to the large number of different features and relations in practice, feature models often become too complex to deal with. One of these complexities is caused by the need to support multiple product lines. In this paper we introduce the concept of a context variability model, which contain the primary drivers for variation, e.g. different geographic regions. The context variability model constrains the feature model, which makes it possible to model multiple product lines supporting several dimensions in the context space. We will discuss how this concept can support software supply chains. Here it can be used to facilitate the process of merging feature models during staged configuration. Our initial experimental results indicate that the approach is intuitive and straightforward to use, and can be applied with commercially available variability management tools.},
	booktitle = {Proc. of the 12th {International} {Software} {Product} {Line} {Conference}},
	publisher = {IEEE},
	author = {Hartmann, H. and Trew, T.},
	month = sep,
	year = {2008},
	keywords = {Automatic control, Automotive engineering, Computer industry, Consumer electronics, Context modeling, context variability model, Engineering management, feature diagrams, feature modeling, feature modelling, Feeds, Merging, multiple product line model, Multiple Product Lines, product development, Product line engineering, Raw materials, software reusability, software supply chains, Staged Configuration, supply chains, variability, variability management tools},
	pages = {12--21},
	file = {IEEE Xplore Abstract Record:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/8HJ93XUJ/abs_all.html:text/html;IEEE Xplore Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/2GTFPPCN/Hartmann and Trew - 2008 - Using Feature Diagrams with Context Variability to.pdf:application/pdf}
}

@inproceedings{heider_using_2012,
	series = {{SPLC} '12},
	title = {Using {Regression} {Testing} to {Analyze} the {Impact} of {Changes} to {Variability} {Models} on {Products}},
	isbn = {978-1-4503-1094-9},
	doi = {10.1145/2362536.2362563},
	abstract = {Industrial product lines are typically maintained for a long time and evolve continuously to address changing requirements and new technologies. Already derived products often have to be re-derived after such changes to benefit from new and updated features. Product line engineers thus frequently need to analyze the impact of changes to variability models to prevent unexpected changes of re-derived products. In this paper we present a tool-supported approach that informs engineers about the impacts of variability model changes on existing products. Regression tests are used to determine whether existing product configurations and generated product outputs can be re-derived without unexpected effects. We evaluate the feasibility of the approach based on changes observed in a real-world software product line. More specifically, we show how our approach helps engineers performing specific evolution tasks to analyze the change impacts on existing products. We also evaluate the performance and scalability of our approach. Our results show that variability change impact analyses can be automated using model regression testing and can help reducing the gap between domain engineering and application engineering.},
	urldate = {2014-03-04},
	booktitle = {Proc. of the 16th {International} {Software} {Product} {Line} {Conference}},
	publisher = {ACM},
	author = {Heider, Wolfgang and Rabiser, Rick and Grünbacher, Paul and Lettner, Daniela},
	year = {2012},
	keywords = {product line evolution, regression testing, variability models},
	pages = {196--205},
	file = {ACM Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/8G7TQ53S/Heider et al. - 2012 - Using Regression Testing to Analyze the Impact of .pdf:application/pdf}
}

@phdthesis{svahnberg_variability_2000,
	title = {Variability in {Evolving} {Software} {Product} {Lines}},
	abstract = {Software reuse is perceived as the key to successful software develop- ment because of the potential for shortened time to market, increased quality and reduced costs. In recent years software product lines have emerged as a promising way to achieve large scale software reuse.
Challenges against successful reuse when developing in a software product line involves management of the differences between products, and the differences between different releases of the products.
In this thesis we present the experiences from a series of case studies within four software companies. Based on these we present a taxonomy of the technical solutions to manage product differences, a historical essay of how components in a software product line can evolve and what mechanisms that are used to support this evolution. From this we elaborate on the connection between evolution and variability, i.e. the ability of the software architecture and components to support the dif- ferences between products.
We argue that evolution is strongly connected to variability, and that by foreseeing the evolution, the software can be instrumented with appropriate variability mechanisms accordingly. Moreover, we argue that some types of evolution are more frequent than others, and that the efforts should mainly go in the direction of foreseeing and instru- menting for these types of evolution.},
	school = {Research Board at Blekinge Institute of Technology},
	author = {Svahnberg, Mikael},
	year = {2000},
	file = {MSV_Thesis_cropped-1.pdf:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/HQTP6E34/MSV_Thesis_cropped-1.pdf:application/pdf}
}

@incollection{bosch_variability_2002,
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Variability {Issues} in {Software} {Product} {Lines}},
	copyright = {©2002 Springer-Verlag Berlin Heidelberg},
	isbn = {978-3-540-43659-1 978-3-540-47833-1},
	url = {http://link.springer.com/chapter/10.1007/3-540-47833-7_3},
	abstract = {Software product lines (or system families) have achieved considerable adoption by the software industry. A software product line captures the commonalities between a set of products while providing for the differences. Differences are managed by delaying design decisions, thereby introducing variation points. The whole of variation points is typically referred to as the variability of the software product line. Variability management is, however, not a trivial activity and several issues exist, both in general as well as specific to individual phases in the lifecycle. This paper identifies and describes several variability issues based on practical experiences and theoretical understanding of the problem domain.},
	number = {2290},
	urldate = {2015-01-22},
	booktitle = {Software {Product}-{Family} {Engineering}},
	publisher = {Springer Berlin Heidelberg},
	author = {Bosch, Jan and Florijn, Gert and Greefhorst, Danny and Kuusela, Juha and Obbink, J. Henk and Pohl, Klaus},
	editor = {Linden, Frank van der},
	year = {2002},
	keywords = {Management of Computing and Information Systems, software engineering},
	pages = {13--21},
	file = {Snapshot:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/4X4TQZH5/3-540-47833-7_3.html:text/html}
}

@article{kastner_variability_2014,
	title = {Variability {Mining}: {Consistent} {Semi}-automatic {Detection} of {Product}-{Line} {Features}},
	volume = {40},
	issn = {0098-5589},
	shorttitle = {Variability {Mining}},
	doi = {10.1109/TSE.2013.45},
	abstract = {Software product line engineering is an efficient means to generate a set of tailored software products from a common implementation. However, adopting a product-line approach poses a major challenge and significant risks, since typically legacy code must be migrated toward a product line. Our aim is to lower the adoption barrier by providing semi-automatic tool support-called variability mining -to support developers in locating, documenting, and extracting implementations of product-line features from legacy code. Variability mining combines prior work on concern location, reverse engineering, and variability-aware type systems, but is tailored specifically for the use in product lines. Our work pursues three technical goals: (1) we provide a consistency indicator based on a variability-aware type system, (2) we mine features at a fine level of granularity, and (3) we exploit domain knowledge about the relationship between features when available. With a quantitative study, we demonstrate that variability mining can efficiently support developers in locating features.},
	number = {1},
	journal = {IEEE Transactions on Software Engineering},
	author = {Kästner, C. and Dreiling, A. and Ostermann, K.},
	month = jan,
	year = {2014},
	keywords = {Companies, consistent semi automatic detection, Context, data mining, Educational institutions, feature, feature extraction, feature location, Java, LEADT, legacy code, mining, product line approach, product line features, reverse engineering, semi automatic tool support, software, software product line, Software Product Line Engineering, software product lines, variability, variability aware type systems, variability mining},
	pages = {67--82},
	file = {IEEE Xplore Abstract Record:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/NGN264AN/abs_all.html:text/html;IEEE Xplore Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/UIAW4SR4/Kästner et al. - 2014 - Variability Mining Consistent Semi-automatic Dete.pdf:application/pdf}
}

@inproceedings{berger_variability_2010,
	series = {{ASE} '10},
	title = {Variability modeling in the real: a perspective from the operating systems domain},
	isbn = {978-1-4503-0116-9},
	shorttitle = {Variability modeling in the real},
	url = {http://portal.acm.org/citation.cfm?doid=1858996.1859010},
	doi = {10.1145/1858996.1859010},
	urldate = {2015-08-20},
	booktitle = {Proceedings of the international conference on {Automated} software engineering},
	publisher = {ACM Press},
	author = {Berger, Thorsten and She, Steven and Lotufo, Rafael and Wasowski, Andrzej and Czarnecki, Krzysztof},
	year = {2010},
	pages = {73}
}

@inproceedings{mietzner_variability_2009,
	title = {Variability modeling to support customization and deployment of multi-tenant-aware {Software} as a {Service} applications},
	isbn = {978-1-4244-3716-0},
	url = {http://ieeexplore.ieee.org/document/5068815/},
	doi = {10.1109/PESOS.2009.5068815},
	urldate = {2016-10-27},
	publisher = {IEEE},
	author = {Mietzner, Ralph and Metzger, Andreas and Leymann, Frank and Pohl, Klaus},
	month = may,
	year = {2009},
	pages = {18--25}
}

@inproceedings{schmid_variability_2013,
	title = {Variability support for variability-rich software ecosystems},
	isbn = {978-1-4673-6449-2},
	doi = {10.1109/PLEASE.2013.6608654},
	urldate = {2014-07-22},
	publisher = {IEEE},
	author = {Schmid, Klaus},
	month = may,
	year = {2013},
	pages = {5--8}
}

@inproceedings{schulze_variant-preserving_2012,
	address = {New York, NY, USA},
	series = {{VaMoS} '12},
	title = {Variant-preserving refactoring in feature-oriented software product lines},
	isbn = {978-1-4503-1058-1},
	url = {http://doi.acm.org/10.1145/2110147.2110156},
	doi = {10.1145/2110147.2110156},
	abstract = {A software product line (SPL) is an advanced concept to manage a family of programs under one umbrella. As with stand-alone programs, maintenance is an important challenge within SPL engineering. One pivotal activity during software maintenance is refactoring; that is, restructuring a program's source code while preserving its external behavior. However, for SPLs, this definition is not sufficient because it does not take into account the behavior of a set of programs. In this paper, we focus on the specific requirements for applying refactorings in feature-oriented SPLs. We propose variant-preserving refactoring for such SPLs to ensure the validity of all SPL variants after refactoring. Furthermore, we present a first approach how the traditional refactoring definition can be extended so that it can be applied to SPLs based on feature-oriented programming. Finally, we state our experiences of applying such refactorings for the removal of code clones in feature-oriented SPLs and discuss the generalizability for other SPL implementation techniques.},
	urldate = {2013-02-20},
	booktitle = {Proceedings of the 6th {International} {Workshop} on {Variability} {Modeling} of {Software}-{Intensive} {Systems}},
	publisher = {ACM},
	author = {Schulze, Sandro and Thüm, Thomas and Kuhlemann, Martin and Saake, Gunter},
	year = {2012},
	keywords = {code clones, Feature-oriented programming, refactoring, software product lines},
	pages = {73--81},
	file = {ACM Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/P68QK2JX/Schulze et al. - 2012 - Variant-preserving refactoring in feature-oriented.pdf:application/pdf}
}

@incollection{hutchison_vision_2011,
	address = {Berlin, Heidelberg},
	title = {Vision {Paper}: {Make} a {Difference}! ({Semantically})},
	volume = {6981},
	isbn = {978-3-642-24484-1 978-3-642-24485-8},
	shorttitle = {Vision {Paper}},
	url = {http://link.springer.com/10.1007/978-3-642-24485-8_36},
	urldate = {2016-11-01},
	booktitle = {Model {Driven} {Engineering} {Languages} and {Systems}},
	publisher = {Springer Berlin Heidelberg},
	author = {Fahrenberg, Uli and Legay, Axel and Wąsowski, Andrzej},
	editor = {Hutchison, David and Kanade, Takeo and Kittler, Josef and Kleinberg, Jon M. and Mattern, Friedemann and Mitchell, John C. and Naor, Moni and Nierstrasz, Oscar and Pandu Rangan, C. and Steffen, Bernhard and Sudan, Madhu and Terzopoulos, Demetri and Tygar, Doug and Vardi, Moshe Y. and Weikum, Gerhard and Whittle, Jon and Clark, Tony and Kühne, Thomas},
	year = {2011},
	pages = {490--500}
}

@inproceedings{berger_what_2015,
	title = {What is a feature?: a qualitative study of features in industrial software product lines},
	isbn = {978-1-4503-3613-0},
	shorttitle = {What is a feature?},
	url = {http://dl.acm.org/citation.cfm?doid=2791060.2791108},
	doi = {10.1145/2791060.2791108},
	urldate = {2016-10-27},
	publisher = {ACM Press},
	author = {Berger, Thorsten and Lettner, Daniela and Rubin, Julia and Grünbacher, Paul and Silva, Adeline and Becker, Martin and Chechik, Marsha and Czarnecki, Krzysztof},
	year = {2015},
	pages = {16--25}
}

@inproceedings{classen_whats_2008,
	address = {Berlin, Heidelberg},
	series = {{FASE}'08/{ETAPS}'08},
	title = {What's in a feature: a requirements engineering perspective},
	isbn = {3-540-78742-9 978-3-540-78742-6},
	shorttitle = {What's in a feature},
	url = {http://dl.acm.org/citation.cfm?id=1792838.1792841},
	abstract = {The notion of feature is heavily used in Software Engineering, especially for software product lines. However, this notion appears to be confusing, mixing various aspects of problem and solution. In this paper, we attempt to clarify the notion of feature in the light of Zave and Jackson's framework for Requirements Engineering. By redefining a problem-level feature as a set of related requirements, specifications and domain assumptions--the three types of statements central to Zave and Jackson's framework--we also revisit the notion of feature interaction. This clarification work opens new perspectives on formal description and verification of software product lines. An important benefit of the approach is to enable an early identification of feature interactions taking place in the systems' environment, a notoriously challenging problem. The approach is illustrated through a proof-of-concept prototype tool and applied to a Smart Home example.},
	urldate = {2012-08-15},
	booktitle = {Proceedings of the {Theory} and practice of software, 11th international conference on {Fundamental} approaches to software engineering},
	publisher = {Springer-Verlag},
	author = {Classen, Andreas and Heymans, Patrick and Schobbens, Pierre-Yves},
	year = {2008},
	pages = {16--30}
}

@inproceedings{kouters_whos_2012,
	title = {Who's who in {Gnome}: {Using} {LSA} to merge software repository identities},
	shorttitle = {Who's who in {Gnome}},
	doi = {10.1109/ICSM.2012.6405329},
	abstract = {Understanding an individual's contribution to an ecosystem often necessitates integrating information from multiple repositories corresponding to different projects within the ecosystem or different kinds of repositories (e.g., mail archives and version control systems). However, recognising that different contributions belong to the same contributor is challenging, since developers may use different aliases. It is known that existing identity merging algorithms are sensitive to large discrepancies between the aliases used by the same individual: the noisier the data, the worse their performance. To assess the scale of the problem for a large software ecosystem, we study all Gnome Git repositories, classify the differences in aliases, and discuss robustness of existing algorithms with respect to these types of differences. We then propose a new identity merging algorithm based on Latent Semantic Analysis (LSA), designed to be robust against more types of differences in aliases, and evaluate it empirically by means of cross-validation on Gnome Git authors. Our results show a clear improvement over existing algorithms in terms of precision and recall on worst-case input data.},
	booktitle = {2012 28th {IEEE} {International} {Conference} on {Software} {Maintenance} ({ICSM})},
	author = {Kouters, E. and Vasilescu, B. and Serebrenik, A. and Brand, M. G. J. van den},
	month = sep,
	year = {2012},
	keywords = {Algorithm design and analysis, alias classification, Birds, Classification algorithms, configuration management, cross-validation, data integration, data noise, Electronic mail, empirical evaluation, Gnome, GNOME Git repositories, identity merging, information integration, latent semantic analysis, LSA, mail archives, Merging, pattern classification, precision value, public domain software, recall value, Robustness, software, software ecosystem, software maintenance, software repository identity merging algorithm, version control systems, worst-case input data},
	pages = {592--595},
	file = {IEEE Xplore Abstract Record:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/QGK5JQM7/abs_all.html:text/html;IEEE Xplore Full Text PDF:/Users/Dante/Library/Application Support/Firefox/Profiles/xsrnq9j3.default/zotero/storage/MGT767ZS/Kouters et al. - 2012 - Who's who in Gnome Using LSA to merge software re.pdf:application/pdf}
}

@inproceedings{ommering_widening_2002,
	series = {{SPLC} '02},
	title = {Widening the {Scope} of {Software} {Product} {Lines} - {From} {Variation} to {Composition}},
	isbn = {3-540-43985-4},
	abstract = {Architecture, components and reuse form the key elements to build a large variety of complex, high-quality products with a short lead-time. But the balance between an architecture-driven and a component-driven approach is influenced by the scope of the product line and the characteristics of the development organization. This paper discusses that balance and claims that a paradigm shift from variation to composition is necessary to cope with an increasing diversity of products created by an ever-larger part of an organization. We illustrate our claim with various examples.},
	urldate = {2014-03-10},
	booktitle = {Proc. of the 2nd {International} {Conference} on {Software} {Product} {Lines}},
	publisher = {Springer-Verlag},
	author = {Ommering, Rob C. van and Bosch, Jan},
	year = {2002},
	keywords = {composition, product population, software components, variation},
	pages = {328--347}
}